#!/bin/bash
if [ -z $1 ] || [ "$1" == "-h" ] || [ "$1" == "-help" ] || [ "$1" == "help" ]; then
    echo "
Simple function scripts library. There are:
$(echo $(cat $0 | grep '(){' | sed 's/(.*//g' | sed 's/\$//g') | sed 's/ /, /g').
Use: $0 func_name func_params OR $0 func_name -h 
Author Andrew S. https://[github OR gitlab].com/quarkscript License GPL
"; exit 0
fi

############################
## functions:

adnlalwp(){
if [ "$1" == "-h" ]; then echo '
## add new line after line with part
## use: adnlalwp "file" "part of line" "new line after previous line" "not contained part of previous line"
## "not contained part of previous line" is optional
## Author Andrew S. Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
'; exit 0; fi
if [ -z "$4" ]
    then 
    lnl=$(grep -n "$2" "$1"  | sed -e 's/:.*//g')
else
    lnl=$(grep -n "$2" "$1" | grep -v "$4" | sed -e 's/:.*//g')
fi
echo "file $1"
line_shift=0
#echo $lnl
    for lnfl in $lnl; do
        l_nm=$(($lnfl+$line_shift))
        head -n $(($l_nm)) $1 >$1.tmp
        echo $3 >>$1.tmp
        tail -n +$(($l_nm+1)) $1 >>$1.tmp
        rm -f $1
        cp -f $1.tmp $1
        rm -f $1.tmp
        echo line No $(($l_nm+1)) was add
        line_shift=$(($line_shift+1))
    done
}

edfpb(){
if [ "$1" == "-h" ]; then echo '
## extract depends from PKGBUILD
## Req.: grep head tail cat
## Use: ./sfslib edfpb "where" "mask" "not contain"
## "where" and "mask" is optional
## Author Andrew S.  Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
'; exit 0; fi

if [ -z "$2" ]
    then
        b='depends='
    else
        b=$2
fi
if [ -z "$1" ]
    then
        a=PKGBUILD
    else
        a=$1
fi
if [ -z "$3" ]; then
    starts=$(cat $a | grep "$b" -no | grep -o [0-9][0-9][0-9:] | sed -e "s/://g")
else
    starts=$(cat $a | grep -v "$3" | grep "$b" -no | grep -o [0-9][0-9][0-9:] | sed -e "s/://g")
fi
ends=$(cat $a | grep ")" -no | grep -o [0-9][0-9][0-9:] | sed -e "s/://g")
deps=1
for j in $starts
    do
        for i in $ends
            do
                if [ "$i" -ge "$j" ]
                    then
                        head -n $i $a >/tmp/dep1.tmp
                        tail -n $(($i-$j+1)) /tmp/dep1.tmp >/tmp/dep2.tmp
                        cat /tmp/dep2.tmp | sed -e 's/:.*//g' | sed -e 's/#.*//g' | sed -e "s/'//g" | sed -e "s/)//g" | sed -e "s/(//g" | sed -e 's/"//g' | sed -e "s/,//g" | sed -e 's/.*=//g' | sed -e "s/$b//g">deps$deps
                        deps=$(($deps+1))
                        rm -r /tmp/dep1.tmp /tmp/dep2.tmp                
                        break
                fi
        done
done
}

mcolif(){
if [ "$1" == "-h" ]; then echo '
## mod component of line in file
## use: mcolif "file" "part of line, contained old part" "old part of line" "new part of line"
## Author Andrew S. Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
'; exit 0; fi 
echo "file $1"
lnl=$(grep -n "$2" "$1" | grep "$3" | sed -e 's/:.*//g')
# lnl=$(grep -n "$2" "$1" | grep -n "$3" "$1" | sed -e 's/:.*//g')
#echo $lnl
    for l_n in $lnl; do
        head -n $(($l_n-1)) $1 >$1.tmp
        head -n $(($l_n)) $1 >wrk.tmp
        tail -n 1 wrk.tmp | sed -e "s/$3/$4/g" >>$1.tmp
        tail -n +$(($l_n+1)) $1 >>$1.tmp
        rm -f $1 wrk.tmp
        cp -f $1.tmp $1
        rm -f $1.tmp
        echo line No $l_n was processed
    done
}

mpbsmpks(){
if [ "$1" != "-u" ] && [ ! -z "$1" ]; then echo '
## mod pkgbuilds and make packages from subdirs
## works with archlinux-based environment only
## use: ./sfslib mpbsmpks or ./sfslib mpbsmpks -u "custom subfolder"
## -u means an update, i.e. build a different versions
## "custom subfolder" if you want to process only specified subfolder
## Author Andrew S. License MIT and/or GPL
## https://github.com/quarkscript/Simple_func_scripts.git
'; exit 0; fi

fl="export CXXFLAGS+='"
fl+=$(cat cxxflags.txt)
fl+=" '"
fl2="export CFLAGS+='"
fl2+=$(cat cxxflags.txt)
fl2+=" '"
if [ -z "$2" ]; then
    fldrs=$(ls -d */ | sed -e 's/\///g')
else
    fldrs=$2
fi
for i in $fldrs
    do
        cd $i
        pkn=$(cat PKGBUILD | grep pkgname= | sed 's/.*=//g')
        pkv=$(cat PKGBUILD | grep pkgver= | sed 's/.*=//g')
        pkr=$(cat PKGBUILD | grep pkgrel= | sed 's/.*=//g')
        ipkn=$(pacman -Qe | grep "$pkn")
        if [ "$1" == "-u" ] && [ "$ipkn" != "$pkn $pkv-$pkr" ] || [ "$1" != "-u" ] ; then
            echo "processing $pkn $pkv-$pkr"
            echo '## try to force compilation flags'
            #../sfslib adnlalwp 'PKGBUILD' 'build()' "$fl"
            adnlalwp 'PKGBUILD' 'build()' "$fl"
            #../sfslib adnlalwp 'PKGBUILD' 'build()' "$fl2"
            adnlalwp 'PKGBUILD' 'build()' "$fl2"
            echo '## try to force smp making'
            #../sfslib mcolif 'PKGBUILD' ' make' ' make' " make -j$(($(grep 'model name' /proc/cpuinfo --count)+1))"
            mcolif 'PKGBUILD' ' make ' ' make ' " make -j$(($(grep 'model name' /proc/cpuinfo --count)+1)) "
            makepkg
            cp *pkg.tar.xz ../
        else
            echo "## pkg: $pkn $pkv-$pkr is already installed"
        fi
        cd ..
done
}

rmdtpi(){
if [ "$1" == "-h" ]; then echo '
## remove duplucates and test packages installation
## Req.: grep cat pacman
## Use: ./sfslib rmdtpi "file list of packages"
## duplicates from "file list of packages" will be removed
## rezult will be "file list of packages".req
## Author Andrew S.  Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
'; exit 0; fi

## rm duplicates
tr=""
for i in $(cat $1)
    do
    if ! $(echo $tr | grep "$i" -q)
        then
        tr+=" "$i
    fi
done
echo $tr>$1

## test req packages
req=""
installed_list=$(pacman -Qq)
for i in $tr
    do
    req+=" "$(echo $i | grep -vx "$installed_list" )
done
echo $req>$1.req
}

rmls(){
if [ "$1" == "-h" ]; then echo '
## rmls - remove lines
## Use: ./sfslib rmls "file" "part of removed line"
## Author Andrew S. Licence GPL
## https://github.com/quarkscript/Simple_func_scripts
'; exit 0; fi

while $(grep -q "$2" "$1"); do
    l_n=$(grep -m 1 -n "$2" "$1" | sed -e 's/:.*//g')
    head -n $(($l_n-1)) $1 >$1.wrk
    tail -n +$(($l_n+1)) $1 >>$1.wrk
    rm -f $1
    cp -f $1.wrk $1
    rm -f $1.wrk
    echo "Line removed"
done 
}

s_un_pk(){
if [ "$1" == "-h" ]; then echo '
## Search unavailable packages from list on official repository
## for purpose to use its as a part of links to Aur
## There are no any checks, so the probability of fail is high
## Author Andrew S. License GPL
'; exit 0; fi
list=""
for i in $1; do
    if $(echo $i | grep -q '.so'); then
        if ! $(pacman -Ss $i | grep -q [a-z]); then
            ## rm duplicates
            if ! $(echo $list | grep "$i" -q); then
                list+="$i "
            fi
        fi
    else
        if ! $(pacman -Ss $i | grep -q "/$i"); then
            ## rm duplicates
            if ! $(echo $list | grep "$i" -q); then
                list+="$i "
            fi
        fi
    fi
done
echo $list
}

skipsha(){
if [ -z $1 ]||[ "$1" == '-h' ]; then 
echo '## It is a part of sfslib. Purpose of this function is
## to remove sha- checks from PKGBUILD
## Usage ./sfslib skipsha "path to PKGBUILD"
## Required: head tail grep sed cat echo
## There are no any checks, so the probability of fail is high
## Author Andrew S. License GPL'
exit 1 ; fi

for pp in $(cat $1 | grep -n sha | grep sums | grep --regexp="=" | sed 's/\:.*//g'); do
    tmpval="$pp $tmpval"
done
for pp in $tmpval; do
    loffset=0
    st=''
    while [ -z "$st" ]; do
        if $(cat $1 | tail -n +"$(($pp+loffset))" | head -n 1 | grep -q  --regexp=")"); then
            st=1
        else
            loffset=$(($loffset+1))
        fi
    done
    count_elmnts=0
    for cld in $(cat $1 | tail -n +"$(($pp+0))" | head -n $(($loffset+1)) | sed 's/.*\=//g' | sed 's/(//g' | sed 's/)//g'); do
        count_elmnts=$(($count_elmnts+1))
    done
    mkshaline=$(cat $1 | tail -n +"$pp" | head -n 1 | sed 's/\=.*//g' )
    mkshaline+="=('SKIP'"
    for ((mr=1;mr<$count_elmnts;mr++)); do
        mkshaline+=" 'SKIP'"
    done
    mkshaline+=")"
    tmmpfl=$(mktemp XXXXXXXXX.tmp)
    cat $1 | head -n $(($pp-1))>$tmmpfl
    echo $mkshaline>>$tmmpfl
    cat $1 | tail -n +"$(($pp+$loffset+1))">>$tmmpfl
    mv -f $tmmpfl $1
done
}

aurget(){
if [ -z "$1" ]||[ "$1" == "-h" ]; then echo "
## aurget - download build and install pkg from AUR with all requirments
## Use: ./sfslib aurget 'ffmpeg-full' 'force install' 'rcbp' 'use_checks'
## 'ffmpeg-full' - name of desired pkg from AUR
## 'force install' fresh install of all requred pkg from AUR; by default '' i.e. no
## 'rcbp' run command before processing, but after clonning, useful for patch or mod
## it will be used to all aur-dependencies-packages, be aware
## 'use_checks' if nonempty then will not remove sha and pgp checks in PKDBUILDs
## There are not all checks, so the probability of fail is high
## Author Andrew S. Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
## https://gitlab.com/quarkscript/arch_linux_scripts/blob/master/pkgs_bulds_scripts/sfslib
"; exit 0; fi

git clone https://aur.archlinux.org/$1.git

if [ ! -f "$1/PKGBUILD" ]; then echo "
    It seems like Arch User Repository doesn't contain 
    $1 package. Exit now."; exit 1
fi

## if cxxflags.txt doesnt exist make it
if [ -f cxxflags.txt ]; then echo ''>cxxflags.txt ; fi

## run command after clonning but before processing, useful for patch or mod
if [ ! -z "$3" ]; then $3 ; fi

## internal function to asqure dependends from PKGBUILD
ask_dep(){
    edfpb "$1/PKGBUILD" "$2" "$3"
    for ji in $(ls -f | grep deps); do 
        cat $ji >> req_all
        rm -f $ji
    done
}
## internal function to get list of required not installed pkgs
getdepslist(){
    rm -f req_all
    ask_dep "$1" "" "optdepends"
    ask_dep "$1" "depends='" "optdepends"
    ask_dep "$1" "depends_x86_64="
    ask_dep "$1" "makedepends"
    ask_dep "$1" "checkdepends=("
    ## rm duplicates from list of packages and test installed pkgs
    if [ -f req_all ]; then
        rmdtpi "req_all"
    fi
    ## make empty file req_all.req if it absent
    if [ ! -f req_all.req ]; then echo "">req_all.req ; fi
}

getdepslist "$1"

aur_deps=''
echo "
Compare requirments and official repository, 
difference will be requested from AUR...
"
for i in $(s_un_pk "$(cat req_all.req)"); do
    aur_deps+="$i "
done
if [ ! -z "$aur_deps" ]; then
    mkdir $1/aur_dependents
    cp -f sfslib $1/aur_dependents/sfslib
    cp -f cxxflags.txt $1/aur_dependents/cxxflags.txt
    if [ ! -z "$3" ]; then 
        cp -f $3 $1/aur_dependents/$3
    fi
    cd $1/aur_dependents
    
    ## make required aur dependecies
    for pks in $aur_deps; do 
        ./sfslib aurget "$pks" "$2" "$3" "$4"
    done
    ##
    
    cd ../..
    
fi

## install required pkgs from system repository
getdepslist "$1"
req_pk_fr_sysrepo=$(echo $(cat req_all.req))
if [ "$req_pk_fr_sysrepo" != "" ]; then
    echo ">> needed package(s):
$(echo $req_pk_fr_sysrepo)
>> sudo password is required to install it"
    sudo pacman -S --needed $req_pk_fr_sysrepo
fi

## remove pgp and sha checks... it's not a good idea actually, but without it there is 
## a high probability of build fail some components that is cause an overall build fail
if [ -z "$4" ]; then
    mcolif "$1/PKGBUILD" '{,.asc}' '{,.asc}' ' "rmasc"'
    echo 'removed pgp signature' >$1/rmasc
    skipsha "$1/PKGBUILD"
fi

## if no force install
if [ -z "$2" ]; then uppd='-u'; else uppd=''; fi

## make asked package
mpbsmpks "$uppd" "$1"
if [ -f $1*pkg.tar.xz ]; then
    echo ">> sudo password is required to install $1"
    sudo pacman -U $1*pkg.tar.xz
fi
}

cxx_flags(){
if [ "$1" == "-h" ]; then echo '
## Try to collect possible local hardware optimization flags
## for gcc (v8/v9), with purpose to use it for any source code
## Req: grep, gcc, sed, hash. Use: ./sfslib cxx_flags
## Author Andrew S. Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
## https://gitlab.com/quarkscript/arch_linux_scripts/blob/master/pkgs_bulds_scripts/sfslib
'; exit 0; fi

if ! (hash gcc 2>/dev/null); then
    echo '-------------------
gcc not found, exit
-------------------'
else
    LANG=C gcc -march=native -v -Q --help=target 1>/tmp/hw_test.txt 2>/tmp/gcc_flags.tmp
    cxxflags=""
    grep enabled /tmp/hw_test.txt > /tmp/capabilities.txt
    if $(cat /tmp/hw_test.txt | grep march | grep -vq armv); then
        for i in prescott nocona core2 nehalem westmere sandybridge ivybridge haswell broadwell skylake bonnell silvermont knl knm skylake-avx512 cannonlake icelake-client icelake-server k8-sse3 opteron-sse3 athlon64-sse3 amdfam10 barcelona bdver1 bdver2 bdver3 bdver4 znver1 btver1 btver2; do
            #if (grep $i /tmp/hw_test.txt -q); then
            if $(cat /tmp/hw_test.txt | grep march | grep $i -q); then
                cxxflags+="-march=$i -mtune=$i "
                arrch=$i
                break
            fi  
        done
        if $(cat /tmp/gcc_flags.tmp | grep -vq mavx); then novex=mavx; else novex="m[ss,mx]"; fi
        for jk in $(cat /tmp/gcc_flags.tmp | grep dumpbase | sed 's/-dumpbase.*//g' | sed 's/.*help-dummy//g'); do
            if $(echo $jk | grep -vq march)&&$(echo $jk | grep -vq mtune)&&$(echo $jk | grep -vq $novex); then
                if $(echo $jk | grep -vq --regexp="-mno-"); then cxxflags+="$jk "; fi
            fi
        done
    else
        echo arm cpu gcc flags collecting is not realized now
    fi
## custom flags spec
    cxxflags+="-fno-strict-aliasing "
    ## Next are a manual selected flags from list
    ## LANG=C gcc --help=optimizers | sed 's/   / # /g' | sed 's/  -/# cxxflags+="-/g' >gccopt
    # cxxflags+="-O<number> #  #  #  #  #  # Set optimization level to <number>.
    # cxxflags+="-Ofast #  #  #  #  #  #  #  Optimize for speed disregarding exact standards compliance.
    # cxxflags+="-Og #  #  #  #  #  #  #  #  Optimize for debugging experience rather than speed or size.
    # cxxflags+="-Os #  #  #  #  #  #  #  #  Optimize for space rather than speed.
    cxxflags+="-faggressive-loop-optimizations " # Aggressively optimize loops using language constraints.
    # cxxflags+="-falign-functions #  #  #   Align the start of functions.
    # cxxflags+="-falign-functions= #  #  #  This option lacks documentation.
    # cxxflags+="-falign-jumps #  #  #  #  # Align labels which are only reached by jumping.
    # cxxflags+="-falign-jumps= #  #  #  #   This option lacks documentation.
    # cxxflags+="-falign-labels #  #  #  #   Align all labels.
    # cxxflags+="-falign-labels= #  #  #  #  This option lacks documentation.
    # cxxflags+="-falign-loops #  #  #  #  # Align the start of loops.
    # cxxflags+="-falign-loops= #  #  #  #   This option lacks documentation.
    # cxxflags+="-fassociative-math #  #  #  Allow optimization for floating-point arithmetic which may change the
    #  #  #  #  #  #  #  #  #  # result of the operation due to rounding.
    # cxxflags+="-fasynchronous-unwind-tables Generate unwind tables that are exact at each instruction boundary.
    # cxxflags+="-fauto-inc-dec #  #  #  #   Generate auto-inc/dec instructions.
    # cxxflags+="-fbranch-count-reg #  #  #  Replace add, compare, branch with branch on count register.
    # cxxflags+="-fbranch-probabilities " #  # Use profiling information for branch probabilities.
    # cxxflags+="-fbranch-target-load-optimize Perform branch target load optimization before prologue / epilogue
    #  #  #  #  #  #  #  #  #  # threading.
    # cxxflags+="-fbranch-target-load-optimize2 Perform branch target load optimization after prologue / epilogue
    #  #  #  #  #  #  #  #  #  # threading.
    # cxxflags+="-fbtr-bb-exclusive #  #  #  Restrict target load migration not to re-use registers in any basic
    #  #  #  #  #  #  #  #  #  # block.
    # cxxflags+="-fcaller-saves #  #  #  #   Save registers around function calls.
    # cxxflags+="-fcode-hoisting #  #  #  #  Enable code hoisting.
    cxxflags+="-fcombine-stack-adjustments " # Looks for opportunities to reduce stack adjustments and stack
    #  #  #  #  #  #  #  #  #  # references.
    # cxxflags+="-fcompare-elim #  #  #  #   Perform comparison elimination after register allocation has finished.
    # cxxflags+="-fconserve-stack #  #  #  # Do not perform optimizations increasing noticeably stack usage.
    cxxflags+="-fcprop-registers " #  #  #   Perform a register copy-propagation optimization pass.
    cxxflags+="-fcrossjumping " #  #  #  #   Perform cross-jumping optimization.
    # cxxflags+="-fcse-follow-jumps #  #  #  When running CSE, follow jumps to their targets.
    # cxxflags+="-fcx-fortran-rules #  #  #  Complex multiplication and division follow Fortran rules.
    # cxxflags+="-fcx-limited-range #  #  #  Omit range reduction step when performing complex division.
    cxxflags+="-fdce " #  #  #  #  #  #  #   Use the RTL dead code elimination pass.
    # cxxflags+="-fdefer-pop #  #  #  #  #   Defer popping functions args from stack until later.
    # cxxflags+="-fdelayed-branch " #  #  #  # Attempt to fill delay slots of branch instructions.
    cxxflags+="-fdelete-dead-exceptions " #  Delete dead instructions that may throw exceptions.
    cxxflags+="-fdelete-null-pointer-checks " #Delete useless null pointer checks.
    # cxxflags+="-fdevirtualize #  #  #  #   Try to convert virtual calls to direct ones.
    # cxxflags+="-fdevirtualize-speculatively Perform speculative devirtualization.
    cxxflags+="-fdse " #  #  #  #  #  #  #   Use the RTL dead store elimination pass.
    # cxxflags+="-fearly-inlining #  #  #  # Perform early inlining.
    # cxxflags+="-fexceptions #  #  #  #  #  Enable exception handling.
    # cxxflags+="-fexpensive-optimizations # Perform a number of minor, expensive optimizations.
    # cxxflags+="-ffast-math #  #  #  #  #   This option lacks documentation.
    # cxxflags+="-ffinite-math-only #  #  #  Assume no NaNs or infinities are generated.
    # cxxflags+="-ffloat-store #  #  #  #  # Don't allocate floats and doubles in extended-precision registers.
    cxxflags+="-fforward-propagate " #  #  # Perform a forward propagation pass on RTL.
    # cxxflags+="-ffp-contract=[off|on|fast] Perform floating-point expression contraction.
    # cxxflags+="-ffp-int-builtin-inexact #  Allow built-in functions ceil, floor, round, trunc to raise "inexact"
    #  #  #  #  #  #  #  #  #  # exceptions.
    # cxxflags+="-ffunction-cse #  #  #  #   Allow function addresses to be held in registers.
    cxxflags+="-fgcse " #  #  #  #  #  #  #  Perform global common subexpression elimination.
    # cxxflags+="-fgcse-after-reload #  #  # Perform global common subexpression elimination after register
    #  #  #  #  #  #  #  #  #  # allocation has finished.
    # cxxflags+="-fgcse-las #  #  #  #  #  # Perform redundant load after store elimination in global common
    #  #  #  #  #  #  #  #  #  # subexpression elimination.
    # cxxflags+="-fgcse-lm #  #  #  #  #  #  Perform enhanced load motion during global common subexpression
    #  #  #  #  #  #  #  #  #  # elimination.
    # cxxflags+="-fgcse-sm #  #  #  #  #  #  Perform store motion after global common subexpression elimination.
    # cxxflags+="-fgraphite #  #  #  #  #  # Enable in and out of Graphite representation.
    # cxxflags+="-fgraphite-identity #  #  # Enable Graphite Identity transformation.
    # cxxflags+="-fguess-branch-probability " #  Enable guessing of branch probabilities.
    # cxxflags+="-fhandle-exceptions #  #  # Same as -fexceptions.  Use the latter option instead.  Uses of this
    #  #  #  #  #  #  #  #  #  # option are diagnosed.
    # cxxflags+="-fhoist-adjacent-loads #  # Enable hoisting adjacent loads to encourage generating conditional
    #  #  #  #  #  #  #  #  #  # move instructions.
    # cxxflags+="-fif-conversion #  #  #  #  Perform conversion of conditional jumps to branchless equivalents.
    cxxflags+="-fif-conversion2 " #  #  #  # Perform conversion of conditional jumps to conditional execution.
    # cxxflags+="-findirect-inlining #  #  # Perform indirect inlining.
    # cxxflags+="-finline #  #  #  #  #  #   Enable inlining of function declared "inline", disabling disables all
    #  #  #  #  #  #  #  #  #  # inlining.
    # cxxflags+="-finline-atomics " #  #  #  # Inline __atomic operations when a lock free instruction sequence is
    #  #  #  #  #  #  #  #  #  # available.
    # cxxflags+="-finline-functions " #  #  #  Integrate functions not declared "inline" into their callers when
    #  #  #  #  #  #  #  #  #  # profitable.
    # cxxflags+="-finline-functions-called-once Integrate functions only required by their single caller.
    # cxxflags+="-finline-small-functions " #  Integrate functions into their callers when code size is known not to
    #  #  #  #  #  #  #  #  #  # grow.
    # cxxflags+="-fipa-bit-cp #  #  #  #  #  Perform interprocedural bitwise constant propagation.
    # cxxflags+="-fipa-cp #  #  #  #  #  #   Perform interprocedural constant propagation.
    # cxxflags+="-fipa-cp-clone #  #  #  #   Perform cloning to make Interprocedural constant propagation stronger.
    # cxxflags+="-fipa-icf #  #  #  #  #  #  Perform Identical Code Folding for functions and read-only variables.
    # cxxflags+="-fipa-icf-functions #  #  # Perform Identical Code Folding for functions.
    # cxxflags+="-fipa-icf-variables #  #  # Perform Identical Code Folding for variables.
    # cxxflags+="-fipa-profile #  #  #  #  # Perform interprocedural profile propagation.
    # cxxflags+="-fipa-pta #  #  #  #  #  #  Perform interprocedural points-to analysis.
    # cxxflags+="-fipa-pure-const #  #  #  # Discover pure and const functions.
    # cxxflags+="-fipa-ra #  #  #  #  #  #   Use caller save register across calls if possible.
    # cxxflags+="-fipa-reference #  #  #  #  Discover readonly and non addressable static variables.
    cxxflags+="-fipa-sra " #  #  #  #  #  #  Perform interprocedural reduction of aggregates.
    # cxxflags+="-fipa-vrp #  #  #  #  #  #  Perform IPA Value Range Propagation.
    # cxxflags+="-fira-algorithm=[CB|priority] Set the used IRA algorithm.
    cxxflags+="-fira-hoist-pressure " #  #   Use IRA based register pressure calculation in RTL hoist
    #  #  #  #  #  #  #  #  #  # optimizations.
    cxxflags+="-fira-loop-pressure " #  #  # Use IRA based register pressure calculation in RTL loop optimizations.
    # cxxflags+="-fira-region=[one|all|mixed] Set regions for IRA.
    cxxflags+="-fira-share-save-slots " #  # Share slots for saving different hard registers.
    # cxxflags+="-fira-share-spill-slots #   Share stack slots for spilled pseudo-registers.
    # cxxflags+="-fisolate-erroneous-paths-attribute Detect paths that trigger erroneous or undefined behavior due
    #  #  #  #  #  #  #  #  #  # to a null value being used in a way forbidden by a returns_nonnull or
    #  #  #  #  #  #  #  #  #  # nonnull attribute.  Isolate those paths from the main control flow
    #  #  #  #  #  #  #  #  #  # and turn the statement with erroneous or undefined behavior into a
    #  #  #  #  #  #  #  #  #  # trap.
    # cxxflags+="-fisolate-erroneous-paths-dereference Detect paths that trigger erroneous or undefined behavior
    #  #  #  #  #  #  #  #  #  # due to dereferencing a null pointer.  Isolate those paths from the
    #  #  #  #  #  #  #  #  #  # main control flow and turn the statement with erroneous or undefined
    #  #  #  #  #  #  #  #  #  # behavior into a trap.
    cxxflags+="-fivopts " #  #  #  #  #  #   Optimize induction variables on trees.
    cxxflags+="-fjump-tables " #  #  #  #  # Use jump tables for sufficiently large switch statements.
    # cxxflags+="-fkeep-gc-roots-live #  #   This option lacks documentation.
    # cxxflags+="-flifetime-dse #  #  #  #   Tell DSE that the storage for a C++ object is dead when the
    #  #  #  #  #  #  #  #  #  # constructor starts and when the destructor finishes.
    # cxxflags+="-flifetime-dse=<0,2> #  #   This option lacks documentation.
    # cxxflags+="-flimit-function-alignment  This option lacks documentation.
    # cxxflags+="-flive-range-shrinkage #  # Relief of register pressure through live range shrinkage.
    cxxflags+="-floop-interchange " #  #  #  Enable loop interchange on trees.
    cxxflags+="-floop-nest-optimize " #  #   Enable the loop nest optimizer.
    # cxxflags+="-floop-parallelize-all #  # Mark all loops as parallel.
    cxxflags+="-floop-unroll-and-jam " #  #  Perform unroll-and-jam on loops.
    # cxxflags+="-flra-remat #  #  #  #  #   Do CFG-sensitive rematerialization in LRA.
    # cxxflags+="-fmath-errno #  #  #  #  #  Set errno after built-in math functions.
    # cxxflags+="-fmodulo-sched #  #  #  #   Perform SMS based modulo scheduling before the first scheduling pass.
    # cxxflags+="-fmodulo-sched-allow-regmoves Perform SMS based modulo scheduling with register moves allowed.
    cxxflags+="-fmove-loop-invariants " #  # Move loop invariant computations out of loops.
    # cxxflags+="-fnon-call-exceptions #  #  Support synchronous non-call exceptions.
    # cxxflags+="-fnothrow-opt #  #  #  #  # Treat a throw() exception specification as noexcept to improve code
    #  #  #  #  #  #  #  #  #  # size.
    cxxflags+="-fomit-frame-pointer " #  #   When possible do not generate stack frames.
    # cxxflags+="-fopt-info #  #  #  #  #  # Enable all optimization info dumps on stderr.
    cxxflags+="-foptimize-sibling-calls " #  Optimize sibling and tail recursive calls.
    cxxflags+="-foptimize-strlen " #  #  #   Enable string length optimizations on trees.
    # cxxflags+="-fpack-struct #  #  #  #  # Pack structure members together without holes.
    # cxxflags+="-fpack-struct=<number> #  # Set initial maximum structure member alignment.
    # cxxflags+="-fpartial-inlining #  #  #  Perform partial inlining.
    # cxxflags+="-fpatchable-function-entry= Insert NOP instructions at each function entry.
    cxxflags+="-fpeel-loops " #  #  #  #  #  Perform loop peeling.
    cxxflags+="-fpeephole " #  #  #  #  #  # Enable machine specific peephole optimizations.
    cxxflags+="-fpeephole2 " #  #  #  #  #   Enable an RTL peephole pass before sched2.
    # cxxflags+="-fplt #  #  #  #  #  #  #   Use PLT for PIC calls (-fno-plt: load the address from GOT at call
    #  #  #  #  #  #  #  #  #  # site).
    cxxflags+="-fpredictive-commoning " #  # Run predictive commoning optimization.
    cxxflags+="-fprefetch-loop-arrays " #  # Generate prefetch instructions, if available, for arrays in loops.
    # cxxflags+="-fprintf-return-value #  #  Treat known sprintf return values as constants.
    # cxxflags+="-freciprocal-math #  #  #   Same as -fassociative-math for expressions which include division.
    cxxflags+="-freg-struct-return " #  #  # Return small aggregates in registers.
    cxxflags+="-frename-registers " #  #  #  Perform a register renaming optimization pass.
    # cxxflags+="-freorder-blocks #  #  #  # Reorder basic blocks to improve code placement.
    # cxxflags+="-freorder-blocks-algorithm=[simple|stc] Set the used basic block reordering algorithm.
    # cxxflags+="-freorder-blocks-and-partition Reorder basic blocks and partition into hot and cold sections.
    # cxxflags+="-freorder-functions #  #  # Reorder functions to improve code placement.
    cxxflags+="-frerun-cse-after-loop " #  # Add a common subexpression elimination pass after loop optimizations.
    # cxxflags+="-freschedule-modulo-scheduled-loops Enable/Disable the traditional scheduling in loops that
    #  #  #  #  #  #  #  #  #  # already passed modulo scheduling.
    # cxxflags+="-frounding-math #  #  #  #  Disable optimizations that assume default FP rounding behavior.
    # cxxflags+="-frtti #  #  #  #  #  #  #  Generate run time type descriptor information.
    # cxxflags+="-fsched-critical-path-heuristic Enable the critical path heuristic in the scheduler.
    # cxxflags+="-fsched-dep-count-heuristic Enable the dependent count heuristic in the scheduler.
    # cxxflags+="-fsched-group-heuristic #   Enable the group heuristic in the scheduler.
    # cxxflags+="-fsched-interblock #  #  #  Enable scheduling across basic blocks.
    # cxxflags+="-fsched-last-insn-heuristic Enable the last instruction heuristic in the scheduler.
    # cxxflags+="-fsched-pressure #  #  #  # Enable register pressure sensitive insn scheduling.
    # cxxflags+="-fsched-rank-heuristic #  # Enable the rank heuristic in the scheduler.
    # cxxflags+="-fsched-spec #  #  #  #  #  Allow speculative motion of non-loads.
    # cxxflags+="-fsched-spec-insn-heuristic Enable the speculative instruction heuristic in the scheduler.
    # cxxflags+="-fsched-spec-load #  #  #   Allow speculative motion of some loads.
    # cxxflags+="-fsched-spec-load-dangerous Allow speculative motion of more loads.
    # cxxflags+="-fsched-stalled-insns #  #  Allow premature scheduling of queued insns.
    # cxxflags+="-fsched-stalled-insns-dep # Set dependence distance checking in premature scheduling of queued
    #  #  #  #  #  #  #  #  #  # insns.
    # cxxflags+="-fsched-stalled-insns-dep=<number> Set dependence distance checking in premature scheduling of
    #  #  #  #  #  #  #  #  #  # queued insns.
    # cxxflags+="-fsched-stalled-insns=<number> Set number of queued insns that can be prematurely scheduled.
    # cxxflags+="-fsched2-use-superblocks #  If scheduling post reload, do superblock scheduling.
    cxxflags+="-fschedule-fusion " #  #  #   Perform a target dependent instruction fusion optimization pass.
    # cxxflags+="-fschedule-insns #  #  #  # Reschedule instructions before register allocation.
    # cxxflags+="-fschedule-insns2 #  #  #   Reschedule instructions after register allocation.
    # cxxflags+="-fsection-anchors #  #  #   Access data in the same section from shared anchor points.
    # cxxflags+="-fsel-sched-pipelining #  # Perform software pipelining of inner loops during selective
    #  #  #  #  #  #  #  #  #  # scheduling.
    # cxxflags+="-fsel-sched-pipelining-outer-loops Perform software pipelining of outer loops during selective
    #  #  #  #  #  #  #  #  #  # scheduling.
    # cxxflags+="-fsel-sched-reschedule-pipelined Reschedule pipelined regions without pipelining.
    # cxxflags+="-fselective-scheduling #  # Schedule instructions using selective scheduling algorithm.
    # cxxflags+="-fselective-scheduling2 #   Run selective scheduling after reload.
    # cxxflags+="-fshort-enums #  #  #  #  # Use the narrowest integer type possible for enumeration types.
    # cxxflags+="-fshort-wchar #  #  #  #  # Force the underlying type for "wchar_t" to be "unsigned short".
    # cxxflags+="-fshrink-wrap #  #  #  #  # Emit function prologues only before parts of the function that need
    #  #  #  #  #  #  #  #  #  # it, rather than at the top of the function.
    cxxflags+="-fshrink-wrap-separate " #  # Shrink-wrap parts of the prologue and epilogue separately.
    # cxxflags+="-fsignaling-nans #  #  #  # Disable optimizations observable by IEEE signaling NaNs.
    # cxxflags+="-fsigned-zeros #  #  #  #   Disable floating point optimizations that ignore the IEEE signedness
    #  #  #  #  #  #  #  #  #  # of zero.
    cxxflags+="-fsimd-cost-model=dynamic "
    # cxxflags+="-fsimd-cost-model=[unlimited|dynamic|cheap] Specifies the vectorization cost model for code
    #  #  #  #  #  #  #  #  #  # marked with a simd directive.
    # cxxflags+="-fsingle-precision-constant Convert floating point constants to single precision constants.
    cxxflags+="-fsplit-ivs-in-unroller " #   Split lifetimes of induction variables when loops are unrolled.
    cxxflags+="-fsplit-loops " #  #  #  #  # Perform loop splitting.
    cxxflags+="-fsplit-paths " #  #  #  #  # Split paths leading to loop backedges.
    # cxxflags+="-fsplit-wide-types #  #  #  Split wide types into independent registers.
    cxxflags+="-fssa-backprop " #  #  #  #   Enable backward propagation of use properties at the SSA level.
    cxxflags+="-fssa-phiopt " #  #  #  #  #  Optimize conditional patterns using SSA PHI nodes.
    # cxxflags+="-fstack-check=[no|generic|specific] Insert stack checking code into the program.
    # cxxflags+="-fstack-clash-protection #  Insert code to probe each page of stack space as it is allocated to
    #  #  #  #  #  #  #  #  #  # protect from stack-clash style attacks.
    # cxxflags+="-fstack-protector #  #  #   Use propolice as a stack protection method.
    # cxxflags+="-fstack-protector-all #  #  Use a stack protection method for every function.
    # cxxflags+="-fstack-protector-explicit  Use stack protection method only for functions with the stack_protect
    #  #  #  #  #  #  #  #  #  # attribute.
    # cxxflags+="-fstack-protector-strong #  Use a smart stack protection method for certain functions.
    # cxxflags+="-fstack-reuse=[all|named_vars|none] Set stack reuse level for local variables.
    cxxflags+="-fstdarg-opt " #  #  #  #  #  Optimize amount of stdarg registers saved to stack at start of
    #  #  #  #  #  #  #  #  #  # function.
    # cxxflags+="-fstore-merging #  #  #  #  Merge adjacent stores.
    # cxxflags+="-fstrict-aliasing #  #  #   Assume strict aliasing rules apply.
    # cxxflags+="-fstrict-enums #  #  #  #   Assume that values of enumeration type are always within the minimum
    #  #  #  #  #  #  #  #  #  # range of that type.
    # cxxflags+="-fstrict-volatile-bitfields Force bitfield accesses to match their type width.
    cxxflags+="-fthread-jumps " #  #  #  #   Perform jump threading optimizations.
    # cxxflags+="-fno-threadsafe-statics #   Do not generate thread-safe code for initializing local statics.
    # cxxflags+="-ftracer #  #  #  #  #  #   Perform superblock formation via tail duplication.
    # cxxflags+="-ftrapping-math #  #  #  #  Assume floating-point operations can trap.
    # cxxflags+="-ftrapv #  #  #  #  #  #  # Trap for signed overflow in addition, subtraction and multiplication.
    cxxflags+="-ftree-bit-ccp " #  #  #  #   Enable SSA-BIT-CCP optimization on trees.
    cxxflags+="-ftree-builtin-call-dce " #   Enable conditional dead code elimination for builtin calls.
    cxxflags+="-ftree-ccp " #  #  #  #  #  # Enable SSA-CCP optimization on trees.
    # cxxflags+="-ftree-ch #  #  #  #  #  #  Enable loop header copying on trees.
    # cxxflags+="-ftree-coalesce-vars #  #   Enable SSA coalescing of user variables.
    # cxxflags+="-ftree-copy-prop #  #  #  # Enable copy propagation on trees.
    cxxflags+="-ftree-cselim " #  #  #  #  # Transform condition stores into unconditional ones.
    cxxflags+="-ftree-dce " #  #  #  #  #  # Enable SSA dead code elimination optimization on trees.
    cxxflags+="-ftree-dominator-opts " #  #  Enable dominator optimizations.
    cxxflags+="-ftree-dse " #  #  #  #  #  # Enable dead store elimination.
    cxxflags+="-ftree-forwprop " #  #  #  #  Enable forward propagation on trees.
    # cxxflags+="-ftree-fre #  #  #  #  #  # Enable Full Redundancy Elimination (FRE) on trees.
    # cxxflags+="-ftree-loop-distribute-patterns Enable loop distribution for patterns transformed into a library
    #  #  #  #  #  #  #  #  #  # call.
    cxxflags+="-ftree-loop-distribution " #  Enable loop distribution on trees.
    # cxxflags+="-ftree-loop-if-convert #  # Convert conditional jumps in innermost loops to branchless
    #  #  #  #  #  #  #  #  #  # equivalents.
    # cxxflags+="-ftree-loop-im #  #  #  #   Enable loop invariant motion on trees.
    # cxxflags+="-ftree-loop-ivcanon #  #  # Create canonical induction variables in loops.
    cxxflags+="-ftree-loop-optimize " #  #   Enable loop optimizations on tree level.
    cxxflags+="-ftree-loop-vectorize " #  #  Enable loop vectorization on trees.
    # cxxflags+="-ftree-lrs #  #  #  #  #  # Perform live range splitting during the SSA->normal pass.
    # cxxflags+="-ftree-parallelize-loops=<number> Enable automatic parallelization of loops.
    # cxxflags+="-ftree-partial-pre #  #  #  In SSA-PRE optimization on trees, enable partial-partial redundancy
    #  #  #  #  #  #  #  #  #  # elimination.
    # cxxflags+="-ftree-phiprop #  #  #  #   Enable hoisting loads from conditional pointers.
    cxxflags+="-ftree-pre " #  #  #  #  #  # Enable SSA-PRE optimization on trees.
    # cxxflags+="-ftree-pta #  #  #  #  #  # Perform function-local points-to analysis on trees.
    # cxxflags+="-ftree-reassoc #  #  #  #   Enable reassociation on tree level.
    # cxxflags+="-ftree-scev-cprop #  #  #   Enable copy propagation of scalar-evolution information.
    # cxxflags+="-ftree-sink #  #  #  #  #   Enable SSA code sinking on trees.
    cxxflags+="-ftree-slp-vectorize " #  #   Enable basic block vectorization (SLP) on trees.
    # cxxflags+="-ftree-slsr #  #  #  #  #   Perform straight-line strength reduction.
    # cxxflags+="-ftree-sra #  #  #  #  #  # Perform scalar replacement of aggregates.
    # cxxflags+="-ftree-switch-conversion #  Perform conversions of switch initializations.
    # cxxflags+="-ftree-tail-merge #  #  #   Enable tail merging on trees.
    # cxxflags+="-ftree-ter #  #  #  #  #  # Replace temporary expressions in the SSA->normal pass.
    cxxflags+="-ftree-vectorize " #  #  #  # Enable vectorization on trees.
    # cxxflags+="-ftree-vrp #  #  #  #  #  # Perform Value Range Propagation on trees.
    # cxxflags+="-funconstrained-commons #   Assume common declarations may be overridden with ones with a larger
    #  #  #  #  #  #  #  #  #  # trailing array.
    # cxxflags+="-funroll-all-loops #  #  #  Perform loop unrolling for all loops.
    cxxflags+="-funroll-loops " #  #  #  #   Perform loop unrolling when iteration count is known.
    # cxxflags+="-funsafe-math-optimizations Allow math optimizations that may violate IEEE or ISO standards.
    # cxxflags+="-funswitch-loops #  #  #  # Perform loop unswitching.
    # cxxflags+="-funwind-tables #  #  #  #  Just generate unwind tables for exception handling.
    # cxxflags+="-fvar-tracking #  #  #  #   Perform variable tracking.
    # cxxflags+="-fvar-tracking-assignments  Perform variable tracking by annotating assignments.
    # cxxflags+="-fvar-tracking-assignments-toggle Toggle -fvar-tracking-assignments.
    # cxxflags+="-fvar-tracking-uninit #  #  Perform variable tracking and also tag variables that are
    #  #  #  #  #  #  #  #  #  # uninitialized.
    # cxxflags+="-fvariable-expansion-in-unroller Apply variable expansion when loops are unrolled.
    cxxflags+="-fvect-cost-model=dynamic "
    #  Specifies the cost model for vectorization. -fvect-cost-model=[unlimited|dynamic|cheap] Specifies
    #  #  #  #  #  #  #  #  #  # the cost model for vectorization.
    # cxxflags+="-fvpt #  #  #  #  #  #  #   Use expression value profiles in optimizations.
    # cxxflags+="-fweb #  #  #  #  #  #  #   Construct webs and split unrelated uses of single variable.
    # cxxflags+="-fwrapv #  #  #  #  #  #  # Assume signed arithmetic overflow wraps around.
    # cxxflags+="-fwrapv-pointer #  #  #  #  Assume pointer overflow wraps around.
    
    rm -f /tmp/hw_test.txt /tmp/capabilities.txt /tmp/gcc_flags.tmp
    echo " "$cxxflags > cxxflags.txt
    #export CXXFLAGS+=$cxxflags
fi
}


############################
## execute required function
$1 "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9"
