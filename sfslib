#!/bin/bash
if [ -z $1 ] || [ "$1" == "-h" ] || [ "$1" == "-help" ] || [ "$1" == "help" ]; then
    echo "
## Simple function scripts library. There are:
   $(echo $(cat $0 | grep '(){' | sed 's/(.*//g' | sed 's/\$//g') | sed 's/ /, /g').
## Use: $0 func_name func_params OR $0 func_name -h 
## Author Andrew S. https://[github OR gitlab].com/quarkscript License GPL
"; exit 0
fi

############################
## functions:

adnlalwp(){
if [ "$1" == "-h" ]; then echo '
## add new line after line with part
## use: adnlalwp "file" "part of line" "new line after previous line" "not contained part of previous line"
## "not contained part of previous line" is optional
## Author Andrew S. Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
'; exit 0; fi
if [ -z "$4" ]
    then 
    lnl=$(grep -n "$2" "$1"  | sed -e 's/:.*//g')
else
    lnl=$(grep -n "$2" "$1" | grep -v "$4" | sed -e 's/:.*//g')
fi
echo "file $1"
line_shift=0
#echo $lnl
    for lnfl in $lnl; do
        l_nm=$(($lnfl+$line_shift))
        head -n $(($l_nm)) $1 >$1.tmp
        echo $3 >>$1.tmp
        tail -n +$(($l_nm+1)) $1 >>$1.tmp
        rm -f $1
        cp -f $1.tmp $1
        rm -f $1.tmp
        echo line No $(($l_nm+1)) was add
        line_shift=$(($line_shift+1))
    done
}

edfpb(){
if [ "$1" == "-h" ]; then echo '
## extract depends from PKGBUILD
## Req.: grep head tail cat
## Use: ./sfslib edfpb "where" "mask" "not contain"
## "where" and "mask" is optional
## Author Andrew S.  Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
'; exit 0; fi

if [ -z "$2" ]
    then
        b='depends='
    else
        b=$2
fi
if [ -z "$1" ]
    then
        a=PKGBUILD
    else
        a=$1
fi
if [ -z "$3" ]; then
    starts=$(cat $a | grep "$b" -no | grep -o [0-9][0-9][0-9:] | sed -e "s/://g")
else
    starts=$(cat $a | grep -v "$3" | grep "$b" -no | grep -o [0-9][0-9][0-9:] | sed -e "s/://g")
fi
ends=$(cat $a | grep ")" -no | grep -o [0-9][0-9][0-9:] | sed -e "s/://g")
deps=1
for j in $starts
    do
        for i in $ends
            do
                if [ "$i" -ge "$j" ]
                    then
                        head -n $i $a >/tmp/dep1.tmp
                        tail -n $(($i-$j+1)) /tmp/dep1.tmp >/tmp/dep2.tmp
                        #cat /tmp/dep2.tmp | sed -e 's/:.*//g' | sed -e 's/#.*//g' | sed -e "s/'//g" | sed -e "s/)//g" | sed -e "s/(//g" | sed -e 's/"//g' | sed -e "s/,//g" | sed -e 's/.*=//g' | sed -e "s/$b//g">deps$deps
                        cat /tmp/dep2.tmp | sed -e 's/:.*//g' | sed -e 's/#.*//g' | sed -e "s/'//g" | sed -e "s/.*\=(//g" | sed -e "s/)//g" | sed -e "s/(//g" | sed -e 's/"//g' | sed -e "s/,//g" >deps$deps #| sed -e 's/[<,>,=].* / /g'>deps$deps
                        deps=$(($deps+1))
                        #rm -r /tmp/dep1.tmp /tmp/dep2.tmp                
                        break
                fi
        done
done
}

mcolif(){
if [ "$1" == "-h" ]; then echo '
## mod component of line in file
## use: mcolif "file" "part of line, contained old part" "old part of line" "new part of line"
## Author Andrew S. Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
'; exit 0; fi 
echo "file $1"
lnl=$(grep -n "$2" "$1" | grep "$3" | sed -e 's/:.*//g')
# lnl=$(grep -n "$2" "$1" | grep -n "$3" "$1" | sed -e 's/:.*//g')
#echo $lnl
    for l_n in $lnl; do
        head -n $(($l_n-1)) $1 >$1.tmp
        head -n $(($l_n)) $1 >wrk.tmp
        tail -n 1 wrk.tmp | sed -e "s/$3/$4/g" >>$1.tmp
        tail -n +$(($l_n+1)) $1 >>$1.tmp
        rm -f $1 wrk.tmp
        cp -f $1.tmp $1
        rm -f $1.tmp
        echo line No $l_n was processed
    done
}

mpbsmpks(){
if [ "$1" != "-u" ] && [ ! -z "$1" ]; then echo '
## mod pkgbuilds and make packages from subdirs
## works with archlinux-based environment only
## use: ./sfslib mpbsmpks or ./sfslib mpbsmpks -u "custom subfolder"
## -u means an update, i.e. build a different versions
## "custom subfolder" if you want to process only specified subfolder
## Author Andrew S. License MIT and/or GPL
## https://github.com/quarkscript/Simple_func_scripts.git
'; exit 0; fi

fl="export CXXFLAGS+='"
fl+=$(cat cxxflags.txt)
fl+=" '"
fl2="export CFLAGS+='"
fl2+=$(cat cxxflags.txt)
fl2+=" '"
if [ -z "$2" ]; then
    fldrs=$(ls -d */ | sed -e 's/\///g')
else
    fldrs=$2
fi
for i in $fldrs
    do
        cd $i
        pkn=$(cat PKGBUILD | grep pkgname= | sed 's/.*=//g')
        pkv=$(cat PKGBUILD | grep pkgver= | sed 's/.*=//g')
        pkr=$(cat PKGBUILD | grep pkgrel= | sed 's/.*=//g')
        ipkn=$(pacman -Qe | grep "$pkn")
        if [ "$1" == "-u" ] && [ "$ipkn" != "$pkn $pkv-$pkr" ] || [ "$1" != "-u" ] ; then
            echo "processing $pkn $pkv-$pkr"
            echo '## try to force compilation flags'
            #../sfslib adnlalwp 'PKGBUILD' 'build()' "$fl"
            adnlalwp 'PKGBUILD' 'build()' "$fl"
            #../sfslib adnlalwp 'PKGBUILD' 'build()' "$fl2"
            adnlalwp 'PKGBUILD' 'build()' "$fl2"
            echo '## try to force smp making'
            #../sfslib mcolif 'PKGBUILD' ' make' ' make' " make -j$(($(grep 'model name' /proc/cpuinfo --count)+1))"
            mcolif 'PKGBUILD' ' make ' ' make ' " make -j$(($(grep 'model name' /proc/cpuinfo --count)+1)) "
            makepkg
            if [ -f *pkg.tar.xz ]; then 
                cp *pkg.tar.xz ../
            elif [ -f *pkg.tar.zst ]; then
                cp *pkg.tar.zst ../
            else
                echo "## it seems pkg $pkn was not build"
            fi
        else
            echo "## pkg: $pkn $pkv-$pkr is already installed"
        fi
        cd ..
done
}

rmdtpi(){
if [ "$1" == "-h" ]; then echo '
## remove duplucates and test packages installation
## Req.: grep cat pacman
## Use: ./sfslib rmdtpi "file list of packages"
## duplicates from "file list of packages" will be removed
## rezult will be "file list of packages".req
## Author Andrew S.  Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
'; exit 0; fi

## rm duplicates
tr=""
for i in $(cat $1)
    do
    ii=$(echo $i | sed -e 's/[<,>,=].*//g')
    if ! $(echo $tr | grep "$ii" -q)
        then
        tr+=" "$ii
    fi
done
echo $tr>$1

## test req packages
req=""
installed_list=$(pacman -Qq)
for i in $tr; do
    req+=" "$(echo $i | grep -vx "$installed_list" )
done
echo $req>$1.req
}

rmls(){
if [ "$1" == "-h" ]; then echo '
## rmls - remove lines
## Use: ./sfslib rmls "file" "part of removed line"
## Author Andrew S. Licence GPL
## https://github.com/quarkscript/Simple_func_scripts
'; exit 0; fi

while $(grep -q "$2" "$1"); do
    l_n=$(grep -m 1 -n "$2" "$1" | sed -e 's/:.*//g')
    head -n $(($l_n-1)) $1 >$1.wrk
    tail -n +$(($l_n+1)) $1 >>$1.wrk
    rm -f $1
    cp -f $1.wrk $1
    rm -f $1.wrk
    echo "Line removed"
done 
}

s_un_pk(){
if [ "$1" == "-h" ]; then echo '
## Search unavailable packages from list on official repository
## for purpose to use its as a part of links to Aur
## There are no any checks, so the probability of fail is high
## Author Andrew S. License GPL
'; exit 0; fi
list=""
for i in $1; do
    if $(echo $i | grep -q '.so'); then
        if ! $(pacman -Ss $i | grep -q [a-z]); then
            ## rm duplicates
            if ! $(echo $list | grep "$i" -q); then
                list+="$i "
            fi
        fi
    else
        if ! $(pacman -Ss $i | grep -q "/$i"); then
            ## rm duplicates
            if ! $(echo $list | grep "$i" -q); then
                list+="$i "
            fi
        fi
    fi
done
echo $list
}

skipsha(){
if [ -z $1 ]||[ "$1" == '-h' ]; then 
echo '## It is a part of sfslib. Purpose of this function is
## to remove sha- checks from PKGBUILD
## Usage ./sfslib skipsha "path to PKGBUILD"
## Required: head tail grep sed cat echo
## There are no any checks, so the probability of fail is high
## Author Andrew S. License GPL'
exit 1 ; fi

for pp in $(cat $1 | grep -n sha | grep sums | grep --regexp="=" | sed 's/\:.*//g'); do
    tmpval="$pp $tmpval"
done
for pp in $tmpval; do
    loffset=0
    st=''
    while [ -z "$st" ]; do
        if $(cat $1 | tail -n +"$(($pp+loffset))" | head -n 1 | grep -q  --regexp=")"); then
            st=1
        else
            loffset=$(($loffset+1))
        fi
    done
    count_elmnts=0
    for cld in $(cat $1 | tail -n +"$(($pp+0))" | head -n $(($loffset+1)) | sed 's/.*\=//g' | sed 's/(//g' | sed 's/)//g'); do
        count_elmnts=$(($count_elmnts+1))
    done
    mkshaline=$(cat $1 | tail -n +"$pp" | head -n 1 | sed 's/\=.*//g' )
    mkshaline+="=('SKIP'"
    for ((mr=1;mr<$count_elmnts;mr++)); do
        mkshaline+=" 'SKIP'"
    done
    mkshaline+=")"
    tmmpfl=$(mktemp XXXXXXXXX.tmp)
    cat $1 | head -n $(($pp-1))>$tmmpfl
    echo $mkshaline>>$tmmpfl
    cat $1 | tail -n +"$(($pp+$loffset+1))">>$tmmpfl
    mv -f $tmmpfl $1
done
}

aurget(){
if [ -z "$1" ]||[ "$1" == "-h" ]; then echo "
## aurget - download build and install pkg from AUR with all requirments
## Use: ./sfslib aurget 'ffmpeg-full' 'force install' 'rcbp' 'use_checks'
## 'ffmpeg-full' - name of desired pkg from AUR
## 'force install' fresh install of all requred pkg from AUR; by default '' i.e. no
## 'rcbp' run command before processing, but after clonning, useful for patch or mod
## it will be used to all aur-dependencies-packages, be aware
## 'use_checks' if nonempty then will not remove sha and pgp checks in PKDBUILDs
## There are not all checks, so the probability of fail is high
## Author Andrew S. Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
## https://gitlab.com/quarkscript/arch_linux_scripts/blob/master/pkgs_bulds_scripts/sfslib
"; exit 0; fi

git clone https://aur.archlinux.org/$1.git

if [ ! -f "$1/PKGBUILD" ]; then echo "
    It seems like Arch User Repository doesn't contain 
    $1 package. Exit now."; exit 1
fi

## if cxxflags.txt doesnt exist make it
if [ ! -f cxxflags.txt ]; then echo ''>cxxflags.txt ; fi

## run command after clonning but before processing, useful for patch or mod
if [ ! -z "$3" ]; then $3 $1 ; fi

## internal function to asqure dependends from PKGBUILD
ask_dep() {
    edfpb "$1/PKGBUILD" "$2" "$3"
    for ji in $(ls -f | grep deps); do 
        cat $ji >> req_all
        rm -f $ji
    done
}
## internal function to get list of required not installed pkgs
getdepslist() {
    rm -f req_all
    ask_dep "$1" "" "optdepends"
    ask_dep "$1" "depends='" "optdepends"
    ask_dep "$1" "depends_x86_64="
    ask_dep "$1" "makedepends"
    ask_dep "$1" "checkdepends=("
    ## rm duplicates from list of packages and test installed pkgs
    if [ -f req_all ]; then
        rmdtpi "req_all"
    fi
    ## make empty file req_all.req if it absent
    if [ ! -f req_all.req ]; then echo "">req_all.req ; fi
}

getdepslist "$1"

if [ ! -z "$2" ]; then cp -f req_all req_all.req; fi

aur_deps=''
echo "
Compare requirments and official repository, 
difference will be requested from AUR...
"
for i in $(s_un_pk "$(cat req_all.req)"); do
    aur_deps+="$i "
done
if [ ! -z "$aur_deps" ]; then
    mkdir $1/aur_dependents
    cp -f sfslib $1/aur_dependents/sfslib
    cp -f cxxflags.txt $1/aur_dependents/cxxflags.txt
    if [ ! -z "$3" ]; then 
        cp -f $3 $1/aur_dependents/$3
    fi
    cd $1/aur_dependents
    
    ## make required aur dependecies
    for pks in $aur_deps; do 
        ./sfslib aurget "$pks" "$2" "$3" "$4"
    done
    ##
    
    cd ../..
    
fi

## install required pkgs from system repository
getdepslist "$1"
req_pk_fr_sysrepo=$(echo $(cat req_all.req))
if [ "$req_pk_fr_sysrepo" != "" ]; then
    echo ">> needed package(s):
$(echo $req_pk_fr_sysrepo)
>> sudo password is required to install it"
    sudo pacman -S --needed $req_pk_fr_sysrepo
fi

## remove pgp and sha checks... it's not a good idea actually, but without it there is 
## a high probability of build fail some components that is cause an overall build fail
if [ -z "$4" ]; then
    mcolif "$1/PKGBUILD" '{,.asc}' '{,.asc}' ' "rmasc"'
    echo 'removed pgp signature' >$1/rmasc
    skipsha "$1/PKGBUILD"
fi

## if no force install
if [ -z "$2" ]; then uppd='-u'; else uppd=''; fi

## make asked package
mpbsmpks "$uppd" "$1"
if [ -f $1*pkg.tar.xz ]; then
    echo ">> sudo password is required to install $1"
    sudo pacman -U $1*pkg.tar.xz
fi
if [ -f $1*pkg.tar.zst ]; then
    echo ">> sudo password is required to install $1"
    sudo pacman -U $1*pkg.tar.zst
fi
}

armget(){
if [ -z "$1" ]||[ "$1" == "-h" ]; then echo "
## run aurget for arm architecture; input argument same as for aurget
## it will fail if any component is already compiled or cannot be compiled for arm
##
## aurget - download build and install pkg from AUR with all requirments
## Use: $0 aurget 'ffmpeg-full' 'force install' 'rcbp' 'use_checks'
## 'ffmpeg-full' - name of desired pkg from AUR
## 'force install' fresh install of all requred pkg from AUR; by default '' i.e. no
## 'rcbp' run command before processing, but after clonning, useful for patch or mod
## it will be used to all aur-dependencies-packages, be aware
## 'use_checks' if nonempty then will not remove sha and pgp checks in PKDBUILDs
## There are not all checks, so the probability of fail is high
## Author Andrew S. https://[gitlab,github].com/quarkscript/ Licence GPL
"; exit 0; fi
 
## if cxxflags.txt doesnt exist make it
if [ ! -f cxxflags.txt ]&&$( uname -m | grep -q armv7l)&&$(cat /proc/cpuinfo | grep -q "Samsung Exynos"); then 
    echo ' -fno-plt -mfloat-abi=hard -mfpu=neon-vfpv4 -pipe -fstack-protector-strong -march=armv7-a+mp+neon --param l1-cache-size=64 --param l2-cache-size=1024 -fno-strict-aliasing -faggressive-loop-optimizations -fcombine-stack-adjustments -fcprop-registers -fcrossjumping -fforward-propagate -fguess-branch-probability -fif-conversion2 -fipa-sra -fira-hoist-pressure -fira-loop-pressure -fira-share-save-slots -fivopts -fjump-tables -floop-interchange -floop-nest-optimize -floop-unroll-and-jam -fmove-loop-invariants -fomit-frame-pointer -foptimize-sibling-calls -foptimize-strlen -fpeel-loops -fpeephole -fpeephole2 -fpredictive-commoning -fprefetch-loop-arrays -freg-struct-return -frename-registers -fschedule-fusion -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops -fshrink-wrap-separate -fsimd-cost-model=dynamic -fsplit-ivs-in-unroller -fsplit-loops -fsplit-paths -fssa-backprop -fssa-phiopt -fstdarg-opt -fthread-jumps -ftree-bit-ccp -ftree-ccp -ftree-cselim -ftree-dominator-opts -ftree-forwprop -ftree-loop-distribution -ftree-loop-optimize -ftree-loop-vectorize -ftree-pre -ftree-slp-vectorize -ftree-vectorize -funroll-loops -fvect-cost-model=dynamic '>cxxflags.txt
elif [ ! -f cxxflags.txt ]; then echo ''>cxxflags.txt ; fi
 echo '#!/bin/bash
 
 if $(cat "$1/PKGBUILD" | grep "arch=" | grep -vq aarch64); then
    ./sfslib mcolif "$1/PKGBUILD" "arch=" "(" "('"'"'aarch64'"'"' "
 fi
 if $(cat "$1/PKGBUILD" | grep "arch=" | grep -vq armv7h); then
    ./sfslib mcolif "$1/PKGBUILD" "arch=" "(" "('"'"'armv7h'"'"' "
 fi
 if $(cat "$1/PKGBUILD" | grep "arch=" | grep -vq armv6h); then
    ./sfslib mcolif "$1/PKGBUILD" "arch=" "(" "('"'"'armv6h'"'"' "
 fi
 ' >>addarmarch
 chmod +x addarmarch
 if [ ! -z "$3" ]&&[ -f "$3" ]; then cat "$3" >>addarmarch
 elif [ ! -z "$3" ]; then echo "$3" >>addarmarch
 fi
 aurget "$1" "$2" "./addarmarch" "$4"
}

cxx_flags(){
if [ "$1" == "-h" ]; then echo '
## Try to collect possible local hardware optimization flags
## for gcc (v10), with purpose to use it for any source code
## Req: grep, gcc, sed, hash. Use: ./sfslib cxx_flags
## Author Andrew S. Licence GPL
## https://github.com/quarkscript/Simple_func_scripts.git
## https://gitlab.com/quarkscript/arch_linux_scripts/blob/master/pkgs_bulds_scripts/sfslib
'; exit 0; fi

if ! (hash gcc 2>/dev/null); then
    echo '-------------------
gcc not found, exit
-------------------'
else
    LANG=C gcc -march=native -v -Q --help=target 1>/tmp/hw_test.txt 2>/tmp/gcc_flags.tmp
    cxxflags=""
    grep enabled /tmp/hw_test.txt > /tmp/capabilities.txt
    if $(cat /tmp/hw_test.txt | grep march | grep -vq armv); then
        for i in prescott nocona core2 nehalem westmere sandybridge ivybridge haswell broadwell skylake bonnell silvermont knl knm skylake-avx512 cannonlake icelake-client icelake-server k8-sse3 opteron-sse3 athlon64-sse3 amdfam10 barcelona bdver1 bdver2 bdver3 bdver4 znver1 btver1 btver2; do
            #if (grep $i /tmp/hw_test.txt -q); then
            if $(cat /tmp/hw_test.txt | grep march | grep $i -q); then
                cxxflags+="-march=$i -mtune=$i "
                arrch=$i
                break
            fi  
        done
        if $(cat /tmp/gcc_flags.tmp | grep -vq mavx); then novex=mavx; else novex="m[ss,mx]"; fi
        for jk in $(cat /tmp/gcc_flags.tmp | grep dumpbase | sed 's/-dumpbase.*//g' | sed 's/.*help-dummy//g'); do
            if $(echo $jk | grep -vq march)&&$(echo $jk | grep -vq mtune)&&$(echo $jk | grep -vq $novex); then
                if $(echo $jk | grep -vq --regexp="-mno-"); then cxxflags+="$jk "; fi
            fi
        done
    else
        echo arm cpu gcc flags collecting is not realized now
    fi
## custom flags spec
    cxxflags+="-fno-strict-aliasing "
    ## Next are a manual selected flags from list
    ## LANG=C gcc --help=optimizers | sed 's/   / # /g' | sed 's/  -/# cxxflags+="-/g' >gccopt
# cxxflags+="-O<number> #  #  #  #  #  # Set optimization level to <number>.
# cxxflags+="-Ofast #  #  #  #  #  #  #  Optimize for speed disregarding exact standards compliance.
# cxxflags+="-Og #  #  #  #  #  #  #  #  Optimize for debugging experience rather than speed or size.
# cxxflags+="-Os #  #  #  #  #  #  #  #  Optimize for space rather than speed.
cxxflags+="-faggressive-loop-optimizations " # Aggressively optimize loops using language constraints.
# cxxflags+="-falign-functions #  #  #   Align the start of functions.
# cxxflags+="-falign-functions= #  #  #  This option lacks documentation.
# cxxflags+="-falign-jumps #  #  #  #  # Align labels which are only reached by jumping.
# cxxflags+="-falign-jumps= #  #  #  #   This option lacks documentation.
# cxxflags+="-falign-labels #  #  #  #   Align all labels.
# cxxflags+="-falign-labels= #  #  #  #  This option lacks documentation.
# cxxflags+="-falign-loops #  #  #  #  # Align the start of loops.
# cxxflags+="-falign-loops= #  #  #  #   This option lacks documentation.
# cxxflags+="-fallocation-dce #  #  #  # Tell DCE to remove unused C++ allocations.
# cxxflags+="-fallow-store-data-races #  Allow the compiler to introduce new data races on stores.
# cxxflags+="-fassociative-math #  #  #  Allow optimization for floating-point arithmetic which may change
 #  #  #  #  #  #  #  #  #  # the result of the operation due to rounding.
# cxxflags+="-fassume-phsa #  #  #  #  # Assume we are finalizing for phsa and its libhsail-rt.  Enables
 #  #  #  #  #  #  #  #  #  # additional phsa-specific optimizations (default).
# cxxflags+="-fasynchronous-unwind-tables Generate unwind tables that are exact at each instruction
 #  #  #  #  #  #  #  #  #  # boundary.
# cxxflags+="-fauto-inc-dec #  #  #  #   Generate auto-inc/dec instructions.
# cxxflags+="-fbranch-count-reg #  #  #  Replace add, compare, branch with branch on count register.
# cxxflags+="-fbranch-probabilities #  # Use profiling information for branch probabilities.
# cxxflags+="-fcaller-saves #  #  #  #   Save registers around function calls.
# cxxflags+="-fcode-hoisting #  #  #  #  Enable code hoisting.
cxxflags+="-fcombine-stack-adjustments " # Looks for opportunities to reduce stack adjustments and stack
 #  #  #  #  #  #  #  #  #  # references.
# cxxflags+="-fcompare-elim #  #  #  #   Perform comparison elimination after register allocation has
 #  #  #  #  #  #  #  #  #  # finished.
# cxxflags+="-fconserve-stack #  #  #  # Do not perform optimizations increasing noticeably stack usage.
cxxflags+="-fcprop-registers " #  #  #   Perform a register copy-propagation optimization pass.
cxxflags+="-fcrossjumping " #  #  #  #   Perform cross-jumping optimization.
# cxxflags+="-fcse-follow-jumps #  #  #  When running CSE, follow jumps to their targets.
# cxxflags+="-fcx-fortran-rules #  #  #  Complex multiplication and division follow Fortran rules.
# cxxflags+="-fcx-limited-range #  #  #  Omit range reduction step when performing complex division.
# cxxflags+="-fdce " #  #  #  #  #  #  #   Use the RTL dead code elimination pass.
# cxxflags+="-fdefer-pop #  #  #  #  #   Defer popping functions args from stack until later.
# cxxflags+="-fdelayed-branch " #  #  #  # Attempt to fill delay slots of branch instructions.
# cxxflags+="-fdelete-dead-exceptions " #  Delete dead instructions that may throw exceptions.
# cxxflags+="-fdelete-null-pointer-checks " # Delete useless null pointer checks.
# cxxflags+="-fdevirtualize #  #  #  #   Try to convert virtual calls to direct ones.
# cxxflags+="-fdevirtualize-speculatively Perform speculative devirtualization.
# cxxflags+="-fdse " #  #  #  #  #  #  #   Use the RTL dead store elimination pass.
# cxxflags+="-fearly-inlining #  #  #  # Perform early inlining.
# cxxflags+="-fexceptions #  #  #  #  #  Enable exception handling.
# cxxflags+="-fexcess-precision=[fast|standard] Specify handling of excess floating-point precision.
# cxxflags+="-fexpensive-optimizations # Perform a number of minor, expensive optimizations.
# cxxflags+="-ffast-math #  #  #  #  #   This option lacks documentation.
# cxxflags+="-ffinite-loops #  #  #  #   Assume that loops with an exit will terminate and not loop
 #  #  #  #  #  #  #  #  #  # indefinitely.
# cxxflags+="-ffinite-math-only #  #  #  Assume no NaNs or infinities are generated.
# cxxflags+="-ffloat-store #  #  #  #  # Don't allocate floats and doubles in extended-precision registers.
cxxflags+="-fforward-propagate " #  #  # Perform a forward propagation pass on RTL.
# cxxflags+="-ffp-contract=[off|on|fast] Perform floating-point expression contraction.
# cxxflags+="-ffp-int-builtin-inexact #  Allow built-in functions ceil, floor, round, trunc to raise
 #  #  #  #  #  #  #  #  #  # "inexact" exceptions.
# cxxflags+="-ffunction-cse #  #  #  #   Allow function addresses to be held in registers.
#cxxflags+="-fgcse " #  #  #  #  #  #  #  Perform global common subexpression elimination.
#cxxflags+="-fgcse-after-reload " #  #  # Perform global common subexpression elimination after register
 #  #  #  #  #  #  #  #  #  # allocation has finished.
# cxxflags+="-fgcse-las #  #  #  #  #  # Perform redundant load after store elimination in global common
 #  #  #  #  #  #  #  #  #  # subexpression elimination.
# cxxflags+="-fgcse-lm #  #  #  #  #  #  Perform enhanced load motion during global common subexpression
 #  #  #  #  #  #  #  #  #  # elimination.
# cxxflags+="-fgcse-sm #  #  #  #  #  #  Perform store motion after global common subexpression
 #  #  #  #  #  #  #  #  #  # elimination.
# cxxflags+="-fgraphite #  #  #  #  #  # Enable in and out of Graphite representation.
# cxxflags+="-fgraphite-identity #  #  # Enable Graphite Identity transformation.
cxxflags+="-fguess-branch-probability " #  Enable guessing of branch probabilities.
# cxxflags+="-fhandle-exceptions #  #  # Same as -fexceptions.  Uses of this option are diagnosed.
# cxxflags+="-fhoist-adjacent-loads #  # Enable hoisting adjacent loads to encourage generating
 #  #  #  #  #  #  #  #  #  # conditional move instructions.
# cxxflags+="-fif-conversion #  #  #  #  Perform conversion of conditional jumps to branchless equivalents.
cxxflags+="-fif-conversion2 " #  #  #  # Perform conversion of conditional jumps to conditional execution.
# cxxflags+="-findirect-inlining #  #  # Perform indirect inlining.
# cxxflags+="-finline #  #  #  #  #  #   Enable inlining of function declared "inline", disabling disables
 #  #  #  #  #  #  #  #  #  # all inlining.
# cxxflags+="-finline-atomics #  #  #  # Inline __atomic operations when a lock free instruction sequence
 #  #  #  #  #  #  #  #  #  # is available.
# cxxflags+="-finline-functions #  #  #  Integrate functions not declared "inline" into their callers when
 #  #  #  #  #  #  #  #  #  # profitable.
# cxxflags+="-finline-functions-called-once Integrate functions only required by their single caller.
# cxxflags+="-finline-small-functions #  Integrate functions into their callers when code size is known
 #  #  #  #  #  #  #  #  #  # not to grow.
# cxxflags+="-fipa-bit-cp #  #  #  #  #  Perform interprocedural bitwise constant propagation.
# cxxflags+="-fipa-cp #  #  #  #  #  #   Perform interprocedural constant propagation.
# cxxflags+="-fipa-cp-clone #  #  #  #   Perform cloning to make Interprocedural constant propagation
 #  #  #  #  #  #  #  #  #  # stronger.
# cxxflags+="-fipa-icf #  #  #  #  #  #  Perform Identical Code Folding for functions and read-only
 #  #  #  #  #  #  #  #  #  # variables.
# cxxflags+="-fipa-icf-functions #  #  # Perform Identical Code Folding for functions.
# cxxflags+="-fipa-icf-variables #  #  # Perform Identical Code Folding for variables.
# cxxflags+="-fipa-profile #  #  #  #  # Perform interprocedural profile propagation.
# cxxflags+="-fipa-pta #  #  #  #  #  #  Perform interprocedural points-to analysis.
# cxxflags+="-fipa-pure-const #  #  #  # Discover pure and const functions.
# cxxflags+="-fipa-ra #  #  #  #  #  #   Use caller save register across calls if possible.
# cxxflags+="-fipa-reference #  #  #  #  Discover read-only and non addressable static variables.
# cxxflags+="-fipa-reference-addressable Discover read-only, write-only and non-addressable static
 #  #  #  #  #  #  #  #  #  # variables.
cxxflags+="-fipa-sra " #  #  #  #  #  #  Perform interprocedural reduction of aggregates.
# cxxflags+="-fipa-stack-alignment #  #  Reduce stack alignment on call sites if possible.
# cxxflags+="-fipa-vrp #  #  #  #  #  #  Perform IPA Value Range Propagation.
# cxxflags+="-fira-algorithm=[CB|priority] Set the used IRA algorithm.
cxxflags+="-fira-hoist-pressure " #  #   Use IRA based register pressure calculation in RTL hoist
 #  #  #  #  #  #  #  #  #  # optimizations.
cxxflags+="-fira-loop-pressure "  #  #  # Use IRA based register pressure calculation in RTL loop
 #  #  #  #  #  #  #  #  #  # optimizations.
# cxxflags+="-fira-region=[one|all|mixed] Set regions for IRA.
cxxflags+="-fira-share-save-slots " #  # Share slots for saving different hard registers.
# cxxflags+="-fira-share-spill-slots #   Share stack slots for spilled pseudo-registers.
# cxxflags+="-fisolate-erroneous-paths-attribute Detect paths that trigger erroneous or undefined behavior
 #  #  #  #  #  #  #  #  #  # due to a null value being used in a way forbidden by a
 #  #  #  #  #  #  #  #  #  # returns_nonnull or nonnull attribute.  Isolate those paths from
 #  #  #  #  #  #  #  #  #  # the main control flow and turn the statement with erroneous or
 #  #  #  #  #  #  #  #  #  # undefined behavior into a trap.
# cxxflags+="-fisolate-erroneous-paths-dereference Detect paths that trigger erroneous or undefined
 #  #  #  #  #  #  #  #  #  # behavior due to dereferencing a null pointer.  Isolate those
 #  #  #  #  #  #  #  #  #  # paths from the main control flow and turn the statement with
 #  #  #  #  #  #  #  #  #  # erroneous or undefined behavior into a trap.
cxxflags+="-fivopts " #  #  #  #  #  #   Optimize induction variables on trees.
cxxflags+="-fjump-tables " #  #  #  #  # Use jump tables for sufficiently large switch statements.
# cxxflags+="-fkeep-gc-roots-live #  #   This option lacks documentation.
# cxxflags+="-flifetime-dse #  #  #  #   Tell DSE that the storage for a C++ object is dead when the
 #  #  #  #  #  #  #  #  #  # constructor starts and when the destructor finishes.
# cxxflags+="-flifetime-dse=<0,2> #  #   This option lacks documentation.
# cxxflags+="-flimit-function-alignment  This option lacks documentation.
# cxxflags+="-flive-patching #  #  #  #  Same as -flive-patching=inline-clone.
# cxxflags+="-flive-patching=[inline-only-static|inline-clone] Control IPA optimizations to provide a safe
 #  #  #  #  #  #  #  #  #  # compilation for live-patching.  At the same time, provides
 #  #  #  #  #  #  #  #  #  # multiple-level control on the enabled IPA optimizations.
# cxxflags+="-flive-range-shrinkage #  # Relief of register pressure through live range shrinkage.
cxxflags+="-floop-interchange " #  #  #  Enable loop interchange on trees.
cxxflags+="-floop-nest-optimize " #  #   Enable the loop nest optimizer.
# cxxflags+="-floop-parallelize-all #  # Mark all loops as parallel.
cxxflags+="-floop-unroll-and-jam " #  #  Perform unroll-and-jam on loops.
# cxxflags+="-flra-remat #  #  #  #  #   Do CFG-sensitive rematerialization in LRA.
# cxxflags+="-fmath-errno #  #  #  #  #  Set errno after built-in math functions.
# cxxflags+="-fmodulo-sched #  #  #  #   Perform SMS based modulo scheduling before the first scheduling
 #  #  #  #  #  #  #  #  #  # pass.
# cxxflags+="-fmodulo-sched-allow-regmoves Perform SMS based modulo scheduling with register moves allowed.
cxxflags+="-fmove-loop-invariants " #  # Move loop invariant computations out of loops.
# cxxflags+="-fnon-call-exceptions #  #  Support synchronous non-call exceptions.
# cxxflags+="-fnothrow-opt #  #  #  #  # Treat a throw() exception specification as noexcept to improve
 #  #  #  #  #  #  #  #  #  # code size.
cxxflags+="-fomit-frame-pointer " #  #   When possible do not generate stack frames.
# cxxflags+="-fopt-info #  #  #  #  #  # Enable all optimization info dumps on stderr.
cxxflags+="-foptimize-sibling-calls " #  Optimize sibling and tail recursive calls.
cxxflags+="-foptimize-strlen " #  #  #   Enable string length optimizations on trees.
# cxxflags+="-fpack-struct #  #  #  #  # Pack structure members together without holes.
# cxxflags+="-fpack-struct=<number> #  # Set initial maximum structure member alignment.
# cxxflags+="-fpartial-inlining #  #  #  Perform partial inlining.
# cxxflags+="-fpatchable-function-entry= Insert NOP instructions at each function entry.
cxxflags+="-fpeel-loops " #  #  #  #  #  Perform loop peeling.
cxxflags+="-fpeephole " #  #  #  #  #  # Enable machine specific peephole optimizations.
cxxflags+="-fpeephole2 " #  #  #  #  #   Enable an RTL peephole pass before sched2.
# cxxflags+="-fplt #  #  #  #  #  #  #   Use PLT for PIC calls (-fno-plt: load the address from GOT at
 #  #  #  #  #  #  #  #  #  # call site).
cxxflags+="-fpredictive-commoning " #  # Run predictive commoning optimization.
cxxflags+="-fprefetch-loop-arrays " #  # Generate prefetch instructions, if available, for arrays in loops.
# cxxflags+="-fprintf-return-value #  #  Treat known sprintf return values as constants.
# cxxflags+="-fprofile-partial-training  Do not assume that functions never executed during the train run
 #  #  #  #  #  #  #  #  #  # are cold.
# cxxflags+="-fprofile-reorder-functions Enable function reordering that improves code placement.
# cxxflags+="-freciprocal-math #  #  #   Same as -fassociative-math for expressions which include division.
# cxxflags+="-free #  #  #  #  #  #  #   Turn on Redundant Extensions Elimination pass.
cxxflags+="-freg-struct-return " #  #  # Return small aggregates in registers.
cxxflags+="-frename-registers " #  #  #  Perform a register renaming optimization pass.
# cxxflags+="-freorder-blocks #  #  #  # Reorder basic blocks to improve code placement.
# cxxflags+="-freorder-blocks-algorithm=[simple|stc] Set the used basic block reordering algorithm.
# cxxflags+="-freorder-blocks-and-partition Reorder basic blocks and partition into hot and cold sections.
# cxxflags+="-freorder-functions #  #  # Reorder functions to improve code placement.
# cxxflags+="-frerun-cse-after-loop " #  # Add a common subexpression elimination pass after loop
 #  #  #  #  #  #  #  #  #  # optimizations.
# cxxflags+="-freschedule-modulo-scheduled-loops Enable/Disable the traditional scheduling in loops that
 #  #  #  #  #  #  #  #  #  # already passed modulo scheduling.
# cxxflags+="-frounding-math #  #  #  #  Disable optimizations that assume default FP rounding behavior.
# cxxflags+="-frtti #  #  #  #  #  #  #  Generate run time type descriptor information.
# cxxflags+="-fsave-optimization-record  Write a SRCFILE.opt-record.json file detailing what optimizations
 #  #  #  #  #  #  #  #  #  # were performed.
# cxxflags+="-fsched-critical-path-heuristic Enable the critical path heuristic in the scheduler.
# cxxflags+="-fsched-dep-count-heuristic Enable the dependent count heuristic in the scheduler.
# cxxflags+="-fsched-group-heuristic #   Enable the group heuristic in the scheduler.
# cxxflags+="-fsched-interblock #  #  #  Enable scheduling across basic blocks.
# cxxflags+="-fsched-last-insn-heuristic Enable the last instruction heuristic in the scheduler.
# cxxflags+="-fsched-pressure #  #  #  # Enable register pressure sensitive insn scheduling.
# cxxflags+="-fsched-rank-heuristic #  # Enable the rank heuristic in the scheduler.
# cxxflags+="-fsched-spec #  #  #  #  #  Allow speculative motion of non-loads.
# cxxflags+="-fsched-spec-insn-heuristic Enable the speculative instruction heuristic in the scheduler.
# cxxflags+="-fsched-spec-load #  #  #   Allow speculative motion of some loads.
# cxxflags+="-fsched-spec-load-dangerous Allow speculative motion of more loads.
# cxxflags+="-fsched-stalled-insns #  #  Allow premature scheduling of queued insns.
# cxxflags+="-fsched-stalled-insns-dep # Set dependence distance checking in premature scheduling of
 #  #  #  #  #  #  #  #  #  # queued insns.
# cxxflags+="-fsched-stalled-insns-dep=<number> Set dependence distance checking in premature scheduling
 #  #  #  #  #  #  #  #  #  # of queued insns.
# cxxflags+="-fsched-stalled-insns=<number> Set number of queued insns that can be prematurely scheduled.
# cxxflags+="-fsched2-use-superblocks #  If scheduling post reload, do superblock scheduling.
cxxflags+="-fschedule-fusion " #  #  #   Perform a target dependent instruction fusion optimization pass.
# cxxflags+="-fschedule-insns #  #  #  # Reschedule instructions before register allocation.
# cxxflags+="-fschedule-insns2 #  #  #   Reschedule instructions after register allocation.
# cxxflags+="-fsection-anchors #  #  #   Access data in the same section from shared anchor points.
cxxflags+="-fsel-sched-pipelining " #  # Perform software pipelining of inner loops during selective
 #  #  #  #  #  #  #  #  #  # scheduling.
cxxflags+="-fsel-sched-pipelining-outer-loops " # Perform software pipelining of outer loops during
 #  #  #  #  #  #  #  #  #  # selective scheduling.
# cxxflags+="-fsel-sched-reschedule-pipelined Reschedule pipelined regions without pipelining.
# cxxflags+="-fselective-scheduling #  # Schedule instructions using selective scheduling algorithm.
# cxxflags+="-fselective-scheduling2 #   Run selective scheduling after reload.
# cxxflags+="-fshort-enums #  #  #  #  # Use the narrowest integer type possible for enumeration types.
# cxxflags+="-fshort-wchar #  #  #  #  # Force the underlying type for "wchar_t" to be "unsigned short".
# cxxflags+="-fshrink-wrap #  #  #  #  # Emit function prologues only before parts of the function that
 #  #  #  #  #  #  #  #  #  # need it, rather than at the top of the function.
cxxflags+="-fshrink-wrap-separate " #  # Shrink-wrap parts of the prologue and epilogue separately.
# cxxflags+="-fsignaling-nans #  #  #  # Disable optimizations observable by IEEE signaling NaNs.
# cxxflags+="-fsigned-zeros #  #  #  #   Disable floating point optimizations that ignore the IEEE
 #  #  #  #  #  #  #  #  #  # signedness of zero.
cxxflags+="-fsimd-cost-model=dynamic "
# cxxflags+="-fsimd-cost-model=[unlimited|dynamic|cheap] Specifies the vectorization cost model for code
 #  #  #  #  #  #  #  #  #  # marked with a simd directive.
# cxxflags+="-fsingle-precision-constant Convert floating point constants to single precision constants.
cxxflags+="-fsplit-ivs-in-unroller " #   Split lifetimes of induction variables when loops are unrolled.
cxxflags+="-fsplit-loops " #  #  #  #  # Perform loop splitting.
cxxflags+="-fsplit-paths " #  #  #  #  # Split paths leading to loop backedges.
# cxxflags+="-fsplit-wide-types #  #  #  Split wide types into independent registers.
# cxxflags+="-fsplit-wide-types-early #  Split wide types into independent registers earlier.
cxxflags+="-fssa-backprop " #  #  #  #   Enable backward propagation of use properties at the SSA level.
cxxflags+="-fssa-phiopt " #  #  #  #  #  Optimize conditional patterns using SSA PHI nodes.
# cxxflags+="-fstack-check=[no|generic|specific] Insert stack checking code into the program.
# cxxflags+="-fstack-clash-protection #  Insert code to probe each page of stack space as it is allocated
 #  #  #  #  #  #  #  #  #  # to protect from stack-clash style attacks.
# cxxflags+="-fstack-protector #  #  #   Use propolice as a stack protection method.
# cxxflags+="-fstack-protector-all #  #  Use a stack protection method for every function.
# cxxflags+="-fstack-protector-explicit  Use stack protection method only for functions with the
 #  #  #  #  #  #  #  #  #  # stack_protect attribute.
# cxxflags+="-fstack-protector-strong #  Use a smart stack protection method for certain functions.
# cxxflags+="-fstack-reuse=[all|named_vars|none] Set stack reuse level for local variables.
cxxflags+="-fstdarg-opt " #  #  #  #  #  Optimize amount of stdarg registers saved to stack at start of
 #  #  #  #  #  #  #  #  #  # function.
# cxxflags+="-fstore-merging #  #  #  #  Merge adjacent stores.
# cxxflags+="-fstrict-aliasing #  #  #   Assume strict aliasing rules apply.
# cxxflags+="-fstrict-enums #  #  #  #   Assume that values of enumeration type are always within the
 #  #  #  #  #  #  #  #  #  # minimum range of that type.
# cxxflags+="-fstrict-volatile-bitfields Force bitfield accesses to match their type width.
cxxflags+="-fthread-jumps " #  #  #  #   Perform jump threading optimizations.
# cxxflags+="-fno-threadsafe-statics #   Do not generate thread-safe code for initializing local statics.
# cxxflags+="-ftoplevel-reorder #  #  #  Reorder top level functions, variables, and asms.
# cxxflags+="-ftracer #  #  #  #  #  #   Perform superblock formation via tail duplication.
# cxxflags+="-ftrapping-math #  #  #  #  Assume floating-point operations can trap.
# cxxflags+="-ftrapv #  #  #  #  #  #  # Trap for signed overflow in addition, subtraction and
 #  #  #  #  #  #  #  #  #  # multiplication.
cxxflags+="-ftree-bit-ccp " #  #  #  #   Enable SSA-BIT-CCP optimization on trees.
# cxxflags+="-ftree-builtin-call-dce " #   Enable conditional dead code elimination for builtin calls.
cxxflags+="-ftree-ccp " #  #  #  #  #  # Enable SSA-CCP optimization on trees.
# cxxflags+="-ftree-ch #  #  #  #  #  #  Enable loop header copying on trees.
# cxxflags+="-ftree-coalesce-vars #  #   Enable SSA coalescing of user variables.
# cxxflags+="-ftree-copy-prop #  #  #  # Enable copy propagation on trees.
cxxflags+="-ftree-cselim " #  #  #  #  # Transform condition stores into unconditional ones.
# cxxflags+="-ftree-dce " #  #  #  #  #  # Enable SSA dead code elimination optimization on trees.
cxxflags+="-ftree-dominator-opts " #  #  Enable dominator optimizations.
# cxxflags+="-ftree-dse " #  #  #  #  #  # Enable dead store elimination.
cxxflags+="-ftree-forwprop " #  #  #  #  Enable forward propagation on trees.
# cxxflags+="-ftree-fre #  #  #  #  #  # Enable Full Redundancy Elimination (FRE) on trees.
# cxxflags+="-ftree-loop-distribute-patterns Enable loop distribution for patterns transformed into a
 #  #  #  #  #  #  #  #  #  # library call.
cxxflags+="-ftree-loop-distribution " #  Enable loop distribution on trees.
# cxxflags+="-ftree-loop-if-convert #  # Convert conditional jumps in innermost loops to branchless
 #  #  #  #  #  #  #  #  #  # equivalents.
# cxxflags+="-ftree-loop-im #  #  #  #   Enable loop invariant motion on trees.
# cxxflags+="-ftree-loop-ivcanon #  #  # Create canonical induction variables in loops.
cxxflags+="-ftree-loop-optimize " #  #   Enable loop optimizations on tree level.
cxxflags+="-ftree-loop-vectorize " #  #  Enable loop vectorization on trees.
# cxxflags+="-ftree-lrs #  #  #  #  #  # Perform live range splitting during the SSA->normal pass.
# cxxflags+="-ftree-parallelize-loops=<number> Enable automatic parallelization of loops.
# cxxflags+="-ftree-partial-pre #  #  #  In SSA-PRE optimization on trees, enable partial-partial
 #  #  #  #  #  #  #  #  #  # redundancy elimination.
# cxxflags+="-ftree-phiprop #  #  #  #   Enable hoisting loads from conditional pointers.
cxxflags+="-ftree-pre " #  #  #  #  #  # Enable SSA-PRE optimization on trees.
# cxxflags+="-ftree-pta #  #  #  #  #  # Perform function-local points-to analysis on trees.
# cxxflags+="-ftree-reassoc #  #  #  #   Enable reassociation on tree level.
# cxxflags+="-ftree-scev-cprop #  #  #   Enable copy propagation of scalar-evolution information.
# cxxflags+="-ftree-sink #  #  #  #  #   Enable SSA code sinking on trees.
cxxflags+="-ftree-slp-vectorize " #  #   Enable basic block vectorization (SLP) on trees.
# cxxflags+="-ftree-slsr #  #  #  #  #   Perform straight-line strength reduction.
# cxxflags+="-ftree-sra #  #  #  #  #  # Perform scalar replacement of aggregates.
# cxxflags+="-ftree-switch-conversion #  Perform conversions of switch initializations.
# cxxflags+="-ftree-tail-merge #  #  #   Enable tail merging on trees.
# cxxflags+="-ftree-ter #  #  #  #  #  # Replace temporary expressions in the SSA->normal pass.
cxxflags+="-ftree-vectorize " #  #  #  # Enable vectorization on trees.
# cxxflags+="-ftree-vrp #  #  #  #  #  # Perform Value Range Propagation on trees.
# cxxflags+="-funconstrained-commons #   Assume common declarations may be overridden with ones with a
 #  #  #  #  #  #  #  #  #  # larger trailing array.
# cxxflags+="-funroll-all-loops #  #  #  Perform loop unrolling for all loops.
cxxflags+="-funroll-loops " #  #  #  #   Perform loop unrolling when iteration count is known.
# cxxflags+="-funsafe-math-optimizations Allow math optimizations that may violate IEEE or ISO standards.
# cxxflags+="-funswitch-loops #  #  #  # Perform loop unswitching.
# cxxflags+="-funwind-tables #  #  #  #  Just generate unwind tables for exception handling.
# cxxflags+="-fvar-tracking #  #  #  #   Perform variable tracking.
# cxxflags+="-fvar-tracking-assignments  Perform variable tracking by annotating assignments.
# cxxflags+="-fvar-tracking-assignments-toggle Toggle -fvar-tracking-assignments.
# cxxflags+="-fvar-tracking-uninit #  #  Perform variable tracking and also tag variables that are
 #  #  #  #  #  #  #  #  #  # uninitialized.
# cxxflags+="-fvariable-expansion-in-unroller Apply variable expansion when loops are unrolled.
cxxflags+="-fvect-cost-model=dynamic "
# cxxflags+="-fvect-cost-model=[unlimited|dynamic|cheap] Specifies the cost model for vectorization.
# cxxflags+="-fversion-loops-for-strides Version loops based on whether indices have a stride of one.
# cxxflags+="-fvpt #  #  #  #  #  #  #   Use expression value profiles in optimizations.
# cxxflags+="-fweb #  #  #  #  #  #  #   Construct webs and split unrelated uses of single variable.
# cxxflags+="-fwrapv #  #  #  #  #  #  # Assume signed arithmetic overflow wraps around.
# cxxflags+="-fwrapv-pointer #  #  #  #  Assume pointer overflow wraps around.
    
    rm -f /tmp/hw_test.txt /tmp/capabilities.txt /tmp/gcc_flags.tmp
    echo " "$cxxflags > cxxflags.txt
    #export CXXFLAGS+=$cxxflags
fi
}

fardu(){
if [ "$1" == "-h" ]; then echo '
## Find And Remove DUplicates from current dir and subdirs
## Req. bash read mktemp sha256sum find wc head tail echo rm cp grep
## There are no any checks...
## Author Andrew S. License GPL [github,gitlab].com/quarkscript
'; exit 0; fi

echo '
        Find And Remove DUplicates from current dir and subdirs
WARNING! any next file with duplicate hash-sum will be deleted
'
read -p "Do you still want to proceed? (YES to continue or CHK) " isrun
if [ "$isrun" != "CHK" ]&&[ "$isrun" != "YES" ]; then echo '    Script terminated.'; exit 0; fi

iamnotstuck() {
                prsy[0]='#  '; prsy[1]=' # '; prsy[2]='  #'; prsy[3]='   '
                rand=$[$RANDOM % ${#prsy[@]}]
                echo -en "\r${prsy[$rand]}"
}
cmphashes() {
                ## $1-filename $2-line number $3-output file name
                curhash=$(head -n $2 $1 2>&1 | tail -n 1 | sed 's/ .*//g')
                lines=$(echo $(cat $1 | tail -n +$(($2+1)) | grep -e $curhash -n | sed 's/\:.*//g'))
                for jojo in $lines; do
                    tmpvariable=$(($jojo+$2))
                    fln=$(head -n $tmpvariable $1 2>&1 | tail -n 1 | sed "s@$curhash  @@g")
                    if ! $(cat $3 | grep -e "$fln" -q); then echo "$fln">>$3; fi
                done
}

flst=$(mktemp XXXXXX.tmp)
maxthreads=$(($(grep 'model name' /proc/cpuinfo --count)+1))
threads=0

find -type f | sed 's|\.\/||g'>$flst

fhashlst=$(mktemp XXXXX.tmp)
for ((lnm=1;lnm<=$(wc -l $flst | sed "s/ $flst//g");lnm+=1)); do
    threads=$(($threads+1))
    sha256sum "$(head -n $lnm $flst 2>&1 | tail -n 1)">>$fhashlst &
    if [ "$threads" == "$maxthreads" ]; then wait; threads=0; iamnotstuck; fi
done
wait

rm_list=$(mktemp XXXXXXX.tmp)
threads=0
for ((lnm=1;lnm<$(wc -l $fhashlst | sed "s/ $fhashlst//g");lnm+=1)); do
    threads=$(($threads+1))
    cmphashes "$fhashlst" "$lnm" "$rm_list" &
    if [ "$threads" == "$maxthreads" ]; then wait; threads=0; iamnotstuck; fi
done
wait
echo -en "\r"
if [ ! -s "$rm_list" ]; then 
    echo "No duplicates found"
elif [ "$isrun" == "CHK" ]; then 
    echo "    Candidates for removal:"
    cat $rm_list
    cp -f $rm_list fardu.list
    echo "    You can find the whole list at fardu.list"
elif [ "$isrun" == "YES" ]; then
    for ((jj=1;jj<=$(wc -l $rm_list | sed "s/ $rm_list//g");jj+=1)); do
        rm -f "$(head -n $jj $rm_list 2>&1 | tail -n 1)"
        echo ' 'removed '"'"$(head -n $jj $rm_list 2>&1 | tail -n 1)"'"'
    done
fi
rm -f $flst $fhashlst $rm_list
}

## The following functions are only for building the Linux kernel

localcpu(){
if [ "$1" == "-h" ]; then echo '
## Tune cpu.patch to local hw
## Req: grep, gcc, sed, lscpu, hash, sha512sum,
##                                   cpu.patch
## Use: ./localcpu
## Author Andrew S.     Licence GPL
## Tested on Arch Linux and Linux Kernel source 5.7.7
## https://github.com/quarkscript/Simple_func_scripts.git
## https://gitlab.com/quarkscript/arch_linux_scripts/blob/master/pkgs_bulds_scripts/sfslib
'; exit 0; fi

if [ ! -e "cpu.patch" ]; then
    echo "
-------------------
cpu.patch not found
nothing to tune
-------------------"
elif ! (hash gcc 2>/dev/null); then
    echo "
-------------------
gcc not found, exit
-------------------"
elif [ -e "localcpu.patch" ]; then
    echo "
---------------------------
localcpu.patch is present
Tunning will not run

to gen a new localcpu.patch
you must remove existing
---------------------------"
else
    if [ "$(gcc -v 2>&1 | grep version | sed 's/.*version //g' | sed 's/\..*//g')" != "10" ]; then
        echo "seems like gcc ver < 10.x"
        sleep 2
    fi

    if [ ! -e "cxxflags.txt" ]; then
        cxx_flags
    fi
    
    cp cpu.patch localcpu.patch
    count=0
    for k in $(cat cxxflags.txt | sed -e 's/--param//g'); do
        if [ "$count" -eq "0" ]; then
            enabl="$k "
            call_cc="$""(call cc-option,$k"
            for i in core2 nehalem westmere silvermont sandybridge ivybridge haswell broadwell skylake k8-sse3 amdfam10 barcelona btver1 bdver1 bdver2 bdver3 btver2 bdver4 znver1 znver2 nocona skylake-avx512 cannonlake icelake cascadelake cooperlake tigerlake; do
                if (grep $i cxxflags.txt -q); then
                    arrch=$i
                fi
            done
        else
            if $(echo $k | grep cache -q); then 
                enabl+="--param $k "
                call_cc+=",$""(call cc-option,--param $k)"
            else
                enabl+="$k "
                call_cc+=",$""(call cc-option,$k)"
            fi
        fi
        count=$(($count+1))
    done
    call_cc+=")"

    if [ -z $arrch ]; then
        echo "
-----------------------------------------------------
CPU type is undetected, tuning of cpu.patch
is not possible for now. It is better to use native
or generic optimizations '('do not forget to patch
kernel source with original cpu.patch')'
-----------------------------------------------------"
        rm -f localcpu.patch
    else
        p_t='Enables -march='$arrch
        if $(grep -q "$p_t" localcpu.patch); then
            l_n=$(grep -n "$p_t" localcpu.patch | sed -e 's/:.*//g')
            head -n $(($l_n-1)) localcpu.patch >patch.patch
            echo "+	  Enables "$enabl>>patch.patch
            tail -n +$(($l_n+1)) localcpu.patch >>patch.patch
            rm -f localcpu.patch
            cp -f patch.patch localcpu.patch
            rm -f patch.patch
        fi
        p_t='$(call cc-option,-march='$arrch',$(call cc-option,-mtune='$arrch'))'
        l_n=$(grep -n "$p_t" localcpu.patch | sed -e 's/:.*//g')
        head -n $(($l_n-1)) localcpu.patch >patch.patch
        echo "+        "$call_cc>>patch.patch
        tail -n +$(($l_n+1)) localcpu.patch >>patch.patch
        rm -f localcpu.patch
        cp -f patch.patch localcpu.patch
        rm -f patch.patch
        echo "
-----------------------------------------------------
Linux kernel could be better optimized to 
CPU $(echo $(grep 'model name' /proc/cpuinfo --max-count=1) | sed 's/  //g')
just patch kernel source with localcpu.patch and
select '$arrch' CPU-family while configuring it
-----------------------------------------------------"
    fi
    if [ "$(sha512sum cpu.patch | sed -e 's/  cpu.patch//')" == "f26616509925a4839a588f56e1b7c10f769062f3d1ea0459359b4ddb27826cd3bf472bdc1865c6998fddb9c4a9975882b71dac497072f03f1c2a291245288f80" ]; then
        patchisknown=1
    elif [ "$(sha512sum cpu.patch | sed -e 's/  cpu.patch//')" == "d10d70371be6a8a6c8c4d63c4bb8c520cea3db9294a8ea2fb2633df3731b4ff56568a04d0216c8097b02b8e48613e93a87be9da24a17be2130cadb6bc2a3536e" ]; then
        patchisknown=1
    else
        echo "
cpu.patch is differ from the expexted..
Wrong source can leads to fails. Be aware"
    fi
fi
}

fti(){
if [ "$1" == "-h" ]; then echo "
## Force Template Integration to kernel config file
## No parameter dependency checking. Double check required
## Use $0 fti OR $0 fti 'template name'
## Required .config Author Andrew S. Licence GPL
## Tested on Arch Linux and Linux Kernel source 5.7.7
## https://github.com/quarkscript/Simple_func_scripts.git
## https://gitlab.com/quarkscript/arch_linux_scripts/blob/master/pkgs_bulds_scripts/sfslib
"; exit 0
## template name
elif [ "$1" != '' ]; then
    t_n="$1"
else
    t_n="conf_tmpl"
fi

## config name
c_n=".config"

t_l_n=$(wc -l "$t_n" | sed "s/ .*//g")
for ((cycle=1;cycle<=$t_l_n;cycle++)) do
    tmpvar1=$(head -n $cycle $t_n | tail -n 1)
    tmpvar2=""
    tmpvar3=""
    if ($(echo $tmpvar1 | grep -q "#")&&$(echo $tmpvar1 | grep -q "is not set")); then
        tmpvar2=$(echo $tmpvar1 | sed "s/# //g" | sed "s/ is not.*//g")
        tmpvar3=$(grep "$tmpvar2[ =]" "$c_n")
    elif ($(echo $tmpvar1 | grep -vq "#")&&$(echo $tmpvar1 | grep -q "=")); then
        tmpvar2=$(echo $tmpvar1 | sed "s/=.*//g")
        tmpvar3=$(grep "$tmpvar2[ =]" "$c_n")
    fi
    if [ "$tmpvar3" != "" ]&&[ "$tmpvar2" != "" ]; then
        if [ "$tmpvar2" != "$tmpvar3" ]; then
            tmpvar4="s@"
            tmpvar4+=$tmpvar3
            tmpvar4+="@"
            tmpvar4+=$tmpvar1
            tmpvar4+="@g"
            sed --expression="$tmpvar4" "$c_n" >$c_n.tmp
            mv -f $c_n.tmp $c_n
        fi
    elif [ "$tmpvar2" != "" ]; then
        echo "$tmpvar1">>$c_n
    fi
done

}

############################
## execute required function
$1 "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9"
